import { string, object, array, literal, number, any, nativeEnum, boolean } from 'zod';
import cloneDeep from 'lodash.clonedeep';
import { BigNumber } from 'bignumber.js';

var _similarChains, _explorerLinkByChain;

var Chains;

(function (Chains) {
  Chains["BitcoinMainnet"] = "Bitcoin";
  Chains["BitcoinTestnet"] = "Bitcoin (Testnet)";
  Chains["EthereumMainnet"] = "Ethereum";
  Chains["EthereumRopsten"] = "Ethereum (Ropsten)";
  Chains["LitecoinMainnet"] = "Litecoin";
  Chains["LitecoinTestnet"] = "Litecoin (Testnet)";
  Chains["BitcoinCashMainnet"] = "Bitcoin Cash";
  Chains["BitcoinCashTestnet"] = "Bitcoin Cash (Testnet)";
  Chains["StellarMainnet"] = "Stellar";
  Chains["StellarTestnet"] = "Stellar (Testnet)";
  Chains["ProtonMainnet"] = "Proton";
  Chains["ProtonTestnet"] = "Proton (Testnet)";
  Chains["PolkadotMainnet"] = "Polkadot";
  Chains["BinanceBEP2"] = "Binance (BEP2)";
  Chains["BinanceBEP20"] = "Binance (BEP20)";
  Chains["EosMainnet"] = "EOS";
  Chains["EosTestnet"] = "EOS (Jungle Testnet)";
  Chains["HederaMainnet"] = "Hedera (Mainnet)";
  Chains["HederaTestnet"] = "Hedera (Testnet)";
  Chains["DogeMainnet"] = "Dogecoin";
  Chains["CardanoMainnet"] = "Cardano";
  Chains["AvalancheXChain"] = "Avalanche X-Chain";
  Chains["AvalancheCChain"] = "Avalanche C-Chain";
  Chains["PolygonMainnet"] = "Polygon";
  Chains["TerraMainnet"] = "Terra";
  Chains["RippleMainnet"] = "Ripple";
  Chains["SolanaMainnet"] = "Solana";
  Chains["MetalXTestnet"] = "Metal X-Chain (Testnet)";
  Chains["MetalCTestnet"] = "Metal C-Chain (Testnet)";
  Chains["MetalCMainnet"] = "Metal C-Chain";
})(Chains || (Chains = {}));

var Networks;

(function (Networks) {
  Networks["Mainnet"] = "mainnet";
  Networks["Testnet"] = "testnet";
  Networks["Ropsten"] = "ropsten";
  Networks["ERC20"] = "erc20";
  Networks["BEP20"] = "bep20";
  Networks["XLM"] = "xlm";
  Networks["AVM"] = "avm";
  Networks["EVM"] = "evm";
})(Networks || (Networks = {}));

var similarChains = (_similarChains = {}, _similarChains[Chains.EthereumMainnet] = [Chains.BinanceBEP20], _similarChains[Chains.BinanceBEP20] = [Chains.EthereumMainnet], _similarChains);
var Providers;

(function (Providers) {
  Providers["FIREBLOCKS"] = "fireblocks";
  Providers["METAL"] = "metal";
})(Providers || (Providers = {}));

var explorerLinkByChain = (_explorerLinkByChain = {}, _explorerLinkByChain[Chains.BitcoinMainnet] = function (txid) {
  return "https://blockchain.com/btc/tx/" + txid;
}, _explorerLinkByChain[Chains.BitcoinTestnet] = function (txid) {
  return "https://blockstream.info/testnet/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumMainnet] = function (txid) {
  return "https://etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.EthereumRopsten] = function (txid) {
  return "https://ropsten.etherscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.LitecoinMainnet] = function (txid) {
  return "https://blockchair.com/litecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.LitecoinTestnet] = function (txid) {
  return "https://blockexplorer.one/litecoin/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashMainnet] = function (txid) {
  return "https://blockchair.com/bitcoin-cash/transaction/" + txid;
}, _explorerLinkByChain[Chains.BitcoinCashTestnet] = function (txid) {
  return "https://blockexplorer.one/bitcoin-cash/testnet/blockHash/" + txid;
}, _explorerLinkByChain[Chains.StellarMainnet] = function (txid) {
  return "https://blockchair.com/stellar/transaction/" + txid;
}, _explorerLinkByChain[Chains.StellarTestnet] = function (txid) {
  return "https://testnet.steexp.com/tx/" + txid;
}, _explorerLinkByChain[Chains.ProtonMainnet] = function (txid, traces) {
  return "https://proton.bloks.io/transaction/" + txid + (traces ? '?tab=traces' : '');
}, _explorerLinkByChain[Chains.ProtonTestnet] = function (txid, traces) {
  return "https://proton-test.bloks.io/transaction/" + txid + (traces ? '?tab=traces' : '');
}, _explorerLinkByChain[Chains.PolkadotMainnet] = function (txid) {
  return "https://polkadot.subscan.io/extrinsic/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP2] = function (txid) {
  return "https://binance.mintscan.io/txs/" + txid;
}, _explorerLinkByChain[Chains.BinanceBEP20] = function (txid) {
  return "https://bscscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.EosMainnet] = function (txid) {
  return "https://bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.EosTestnet] = function (txid) {
  return "https://jungle.bloks.io/transaction/" + txid;
}, _explorerLinkByChain[Chains.HederaMainnet] = function (txid) {
  return "https://app.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.HederaTestnet] = function (txid) {
  return "https://testnet.dragonglass.me/transactions/" + txid;
}, _explorerLinkByChain[Chains.DogeMainnet] = function (txid) {
  return "https://blockchair.com/dogecoin/transaction/" + txid;
}, _explorerLinkByChain[Chains.CardanoMainnet] = function (txid) {
  return "https://explorer.cardano.org/en/transaction?id=" + txid;
}, _explorerLinkByChain[Chains.AvalancheXChain] = function (txid) {
  return "https://avascan.info/blockchain/x/tx/" + txid;
}, _explorerLinkByChain[Chains.AvalancheCChain] = function (txid) {
  return "https://snowtrace.io/tx/" + txid;
}, _explorerLinkByChain[Chains.PolygonMainnet] = function (txid) {
  return "https://polygonscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.TerraMainnet] = function (txid) {
  return "https://terra.stake.id/?#/tx/" + txid;
}, _explorerLinkByChain[Chains.RippleMainnet] = function (txid) {
  return "https://xrpscan.com/tx/" + txid;
}, _explorerLinkByChain[Chains.SolanaMainnet] = function (txid) {
  return "https://explorer.solana.com/tx/" + txid;
}, _explorerLinkByChain[Chains.MetalXTestnet] = function (txid) {
  return "https://metalscan.io/tx/" + txid;
}, _explorerLinkByChain[Chains.MetalCTestnet] = function (txid) {
  return "https://tahoe.metaltrace.io/tx/" + txid;
}, _explorerLinkByChain[Chains.MetalCMainnet] = function (txid) {
  return "https://metalscan.io/tx/" + txid;
}, _explorerLinkByChain);
var protonExplorerTxUrl = function protonExplorerTxUrl(chain, txId, traces) {
  return chain === 'proton' ? explorerLinkByChain[Chains.ProtonMainnet](txId, traces) : explorerLinkByChain[Chains.ProtonTestnet](txId, traces);
}; // Initialize.

var initializeCoins = function initializeCoins(protonChain) {
  var IS_MAINNET = protonChain === 'proton';
  var IS_TESTNET = protonChain === 'proton-test';
  var coins = [{
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Proton',
    coin: 'XPR',
    xtokenSymbol: 'XPR',
    xtokenPrecision: 4,
    xtokenContract: 'eosio.token',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XPR-ERC20',
      symbol: 'XPR',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 4,
      contract: '0xD7EFB00D12C2C13131FD319336FDF952525DA2AF',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }, {
      wallet: 'XPR-BEP20',
      symbol: 'XPR',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 4,
      contract: '0x5DE3939B2F811A61D830E6F52D13B066881412AB',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/eosio-tokenXPR.png',
    coingeckoId: 'proton'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'USD Coin',
    coin: 'USDC',
    xtokenSymbol: 'XUSDC',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-BEP20',
      symbol: 'USDC',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: '0x8AC76A51CC950D9822D68B83FE1AD97B32CD580D',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-XLM',
      symbol: 'USDC',
      chain: Chains.StellarMainnet,
      network: Networks.XLM,
      precision: 7,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'USDC',
      symbol: 'USDC',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xA0B86991C6218B36C1D19D4A2E9EB0CE3606EB48',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }, {
      wallet: 'USDC-XLM',
      symbol: 'USDC',
      chain: Chains.StellarTestnet,
      network: Networks.XLM,
      precision: 7,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXUSDC.png',
    coingeckoId: 'usd-coin'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Metal DAO',
    coin: 'MTL',
    xtokenSymbol: 'XMT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MTL',
      symbol: 'MTL',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 8,
      contract: '0xF433089366899D83A9F26A773D59EC7ECF30355E',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXMT.png',
    coingeckoId: 'metal'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Metal Blockchain',
    coin: 'METAL',
    xtokenSymbol: 'METAL',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_TESTNET ? [{
      wallet: 'METAL',
      symbol: 'METAL',
      chain: Chains.MetalCTestnet,
      network: Networks.EVM,
      precision: 18,
      contract: '',
      provider: Providers.METAL,
      hasWithdrawMemo: false
    }] : [], IS_MAINNET ? [{
      wallet: 'METAL',
      symbol: 'METAL',
      chain: Chains.MetalCMainnet,
      network: Networks.EVM,
      precision: 18,
      contract: '',
      provider: Providers.METAL,
      hasWithdrawMemo: false
    }, {
      wallet: 'METAL',
      symbol: 'METAL',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/metal-chain.png',
    coingeckoId: 'metal-blockchain'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Bitcoin',
    coin: 'BTC',
    xtokenSymbol: 'XBTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BTC',
      symbol: 'BTC',
      chain: Chains.BitcoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXBTC.png',
    coingeckoId: 'bitcoin'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: true,
    allowBorrow: true,
    name: 'Ethereum',
    coin: 'ETH',
    xtokenSymbol: 'XETH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'ETH',
      symbol: 'ETH',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXETH.png',
    coingeckoId: 'ethereum'
  }, {
    allowSwap: true,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Loan',
    coin: 'LOAN',
    xtokenSymbol: 'LOAN',
    xtokenPrecision: 4,
    xtokenContract: 'loan.token',
    wallets: [],
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/loan.png',
    coingeckoId: 'proton-loan'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Tether',
    coin: 'USDT',
    xtokenSymbol: 'XUSDT',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_MAINNET ? [{
      wallet: 'USDT-BEP20',
      symbol: 'USDT',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: '0x55d398326f99059fF775485246999027B3197955',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'USDT',
      symbol: 'USDT',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 6,
      contract: '0xDAC17F958D2EE523A2206206994597C13D831EC7',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXUSDT.png',
    coingeckoId: 'tether'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'TrueUSD',
    coin: 'TUSD',
    xtokenSymbol: 'XTUSD',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'TUSD',
      symbol: 'TUSD',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x0000000000085D4780B73119B644AE5ECD22B376',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXTUSD.png',
    coingeckoId: 'true-usd'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Dollar',
    coin: 'PAX',
    xtokenSymbol: 'XPAX',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAX',
      symbol: 'PAX',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x8E870D67F660D95D5BE530380D0EC0BD388289E1',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXPAX.png',
    coingeckoId: 'paxos-standard'
  }, {
    allowSwap: false,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Paxos Gold',
    coin: 'PAXG',
    xtokenSymbol: 'XPAXG',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'PAXG',
      symbol: 'PAXG',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x45804880DE22913DAFE09F4980848ECE6ECBAF78',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXPAXG.png',
    coingeckoId: 'pax-gold'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Storex',
    coin: 'STRX',
    xtokenSymbol: 'STRX',
    xtokenPrecision: 4,
    xtokenContract: 'storex',
    wallets: [],
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/strx.png',
    coingeckoId: ''
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Mint',
    coin: 'MINT',
    xtokenSymbol: 'MINT',
    xtokenPrecision: 4,
    xtokenContract: 'protonmint',
    wallets: [],
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/PMLogo-04.png',
    coingeckoId: ''
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Snipcoins',
    coin: 'SNIPS',
    xtokenSymbol: 'SNIPS',
    xtokenPrecision: 4,
    xtokenContract: 'snipcoins',
    wallets: [],
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/snips.png',
    coingeckoId: ''
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Uniswap',
    coin: 'UNI',
    xtokenSymbol: 'XUNI',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'UNI',
      symbol: 'UNI',
      chain: Chains.EthereumRopsten,
      network: Networks.Ropsten,
      precision: 18,
      contract: '0x1F9840A85D5AF5BF1D1762F925BDADDC4201F984',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXUNI.png',
    coingeckoId: 'uniswap'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: '1INCH',
    coin: '1INCH',
    xtokenSymbol: 'XINCH',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: '1INCH',
      symbol: '1INCH',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x111111111117DC0AA78B770FA6A738034120C302',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXINCH.png',
    coingeckoId: '1inch'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Chainlink',
    coin: 'LINK',
    xtokenSymbol: 'XLINK',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LINK',
      symbol: 'LINK',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 18,
      contract: '0x514910771AF9CA656AF840DFF83E8264ECF986CA',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXLINK.png',
    coingeckoId: 'chainlink'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Litecoin',
    coin: 'LTC',
    xtokenSymbol: 'XLTC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'LTC',
      symbol: 'LTC',
      chain: Chains.LitecoinTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXLTC.png',
    coingeckoId: 'litecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'Bitcoin Cash',
    coin: 'BCH',
    xtokenSymbol: 'XBCH',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : [], IS_TESTNET ? [{
      wallet: 'BCH',
      symbol: 'BCH',
      chain: Chains.BitcoinCashTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXBCH.png',
    coingeckoId: 'bitcoin-cash'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'LunarCrush',
    coin: 'LUNR',
    xtokenSymbol: 'XLUNR',
    xtokenPrecision: 4,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'LUNR',
      symbol: 'LUNR',
      chain: Chains.EthereumMainnet,
      network: Networks.ERC20,
      precision: 4,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/xlunr.png',
    coingeckoId: 'lunr-token'
  }, {
    allowSwap: false,
    allowBridge: IS_TESTNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Stellar',
    coin: 'XLM',
    xtokenSymbol: 'XXLM',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarMainnet,
      network: Networks.Mainnet,
      precision: 7,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'XLM',
      symbol: 'XLM',
      chain: Chains.StellarTestnet,
      network: Networks.Testnet,
      precision: 7,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXXLM.png',
    coingeckoId: 'stellar'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Sense',
    coin: 'SENSE',
    xtokenSymbol: 'XSENSE',
    xtokenPrecision: 4,
    xtokenContract: 'sense',
    wallets: [],
    image: 'https://www.proton.org/images/tokens/senseXSENSE.png',
    coingeckoId: 'sense'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polkadot',
    coin: 'DOT',
    xtokenSymbol: 'XDOT',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOT',
      symbol: 'DOT',
      chain: Chains.PolkadotMainnet,
      network: Networks.Mainnet,
      precision: 10,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXDOT.png',
    coingeckoId: 'polkadot'
  }, {
    allowSwap: true,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Binance Coin',
    coin: 'BNB',
    xtokenSymbol: 'XBNB',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BNB',
      symbol: 'BNB',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXBNB.png',
    coingeckoId: 'binancecoin'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Binance USD',
    coin: 'BUSD',
    xtokenSymbol: 'XBUSD',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'BUSD-BEP20',
      symbol: 'BUSD',
      chain: Chains.BinanceBEP20,
      network: Networks.BEP20,
      precision: 18,
      contract: '0xe9e7cea3dedca5984780bafc599bd69add087d56',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/xbusd.png',
    coingeckoId: 'binance-usd'
  }, {
    allowSwap: true,
    allowBridge: true,
    allowLend: false,
    allowBorrow: false,
    name: 'EOS',
    coin: 'EOS',
    xtokenSymbol: 'XEOS',
    xtokenPrecision: 4,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosMainnet,
      network: Networks.Mainnet,
      precision: 4,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : [], IS_TESTNET ? [{
      wallet: 'EOS',
      symbol: 'EOS',
      chain: Chains.EosTestnet,
      network: Networks.Testnet,
      precision: 4,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXEOS.png',
    coingeckoId: 'eos'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: true,
    allowBorrow: true,
    name: 'Dogecoin',
    coin: 'DOGE',
    xtokenSymbol: 'XDOGE',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'DOGE',
      symbol: 'DOGE',
      chain: Chains.DogeMainnet,
      network: Networks.Mainnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXDOGE.png',
    coingeckoId: 'dogecoin'
  }, {
    allowSwap: IS_MAINNET,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Cardano',
    coin: 'ADA',
    xtokenSymbol: 'XADA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'ADA',
      symbol: 'ADA',
      chain: Chains.CardanoMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXADA.png',
    coingeckoId: 'cardano'
  }, // Adding
  {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Terra',
    coin: 'LUNA',
    xtokenSymbol: 'XLUNA',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [// ...(IS_MAINNET ? [{
      //     wallet: 'LUNA',
      //     symbol: 'LUNA',
      //     chain: Chains.TerraMainnet,
      //     network: Networks.Mainnet,
      //     precision: 6,
      //     contract: undefined,
      //     provider: Providers.FIREBLOCKS,
      //     hasWithdrawMemo: true
      // }]: [])
    ],
    image: 'https://www.proton.org/images/tokens/xtokensXLUNA.png',
    coingeckoId: 'terra-luna'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'TerraUSD',
    coin: 'UST',
    xtokenSymbol: 'XUST',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'UST',
      symbol: 'UST',
      chain: Chains.TerraMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXUST.png',
    coingeckoId: 'terrausd'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Solana',
    coin: 'SOL',
    xtokenSymbol: 'XSOL',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'SOL',
      symbol: 'SOL',
      chain: Chains.SolanaMainnet,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/xsol.png',
    coingeckoId: 'solana'
  }, {
    allowSwap: false,
    allowBridge: IS_MAINNET,
    allowLend: false,
    allowBorrow: false,
    name: 'Ripple',
    coin: 'XRP',
    xtokenSymbol: 'XXRP',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'XRP',
      symbol: 'XRP',
      chain: Chains.RippleMainnet,
      network: Networks.Mainnet,
      precision: 6,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://raw.githubusercontent.com/eoscafe/eos-airdrops/master/logos/xxrp.png',
    coingeckoId: 'ripple'
  }, // Future
  {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Avalanche',
    coin: 'AVAX',
    xtokenSymbol: 'XAVAX',
    xtokenPrecision: 9,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'AVAX',
      symbol: 'AVAX',
      chain: Chains.AvalancheCChain,
      network: Networks.Mainnet,
      precision: 9,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXAVAX.png',
    coingeckoId: 'avalanche-2'
  }, {
    allowSwap: false,
    allowBridge: false,
    allowLend: false,
    allowBorrow: false,
    name: 'Polygon',
    coin: 'MATIC',
    xtokenSymbol: 'XMATIC',
    xtokenPrecision: 8,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_MAINNET ? [{
      wallet: 'MATIC',
      symbol: 'MATIC',
      chain: Chains.PolygonMainnet,
      network: Networks.Mainnet,
      precision: 18,
      contract: '0x0000000000000000000000000000000000000000',
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: false
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXMATIC.png',
    coingeckoId: 'matic-network'
  }, {
    allowSwap: false,
    allowBridge: IS_TESTNET,
    allowLend: false,
    allowBorrow: false,
    name: 'HBAR',
    coin: 'HBAR',
    xtokenSymbol: 'XHBAR',
    xtokenPrecision: 6,
    xtokenContract: 'xtokens',
    wallets: [].concat(IS_TESTNET ? [{
      wallet: 'HBAR',
      symbol: 'HBAR',
      chain: Chains.HederaTestnet,
      network: Networks.Testnet,
      precision: 8,
      contract: undefined,
      provider: Providers.FIREBLOCKS,
      hasWithdrawMemo: true
    }] : []),
    image: 'https://www.proton.org/images/tokens/xtokensXHBAR.png',
    coingeckoId: 'hedera-hashgraph'
  }]; // Validation

  var walletWithDuplicateChains = coins.find(function (coin) {
    var chains = coin.wallets.map(function (wallet) {
      return wallet.chain;
    });
    return new Set(chains).size !== chains.length;
  });

  if (walletWithDuplicateChains) {
    throw new Error("Coin " + walletWithDuplicateChains.coin + " has duplicate chains in wallet");
  }

  return {
    allCoins: coins,
    swapCoins: coins.filter(function (coin) {
      return coin.allowSwap;
    }),
    bridgeCoins: coins.filter(function (coin) {
      return coin.allowBridge;
    }),
    lendCoins: coins.filter(function (coin) {
      return coin.allowLend;
    }),
    borrowCoins: coins.filter(function (coin) {
      return coin.allowBorrow;
    }),
    loanCoins: coins.filter(function (coin) {
      return coin.allowLend || coin.allowBorrow;
    }),
    allEnabledCoins: coins.filter(function (coin) {
      return coin.allowSwap || coin.allowBridge;
    })
  };
};

var accountParser = /*#__PURE__*/string().regex(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);
var authorizationParser = /*#__PURE__*/object({
  actor: accountParser,
  permission: /*#__PURE__*/string()
});
var authorizationsParser = /*#__PURE__*/array(authorizationParser).min(1);
var ExtendedAssetParser = /*#__PURE__*/object({
  quantity: /*#__PURE__*/string(),
  contract: accountParser
});

var actionParser = /*#__PURE__*/object({
  account: /*#__PURE__*/string(),
  name: /*#__PURE__*/string(),
  authorization: /*#__PURE__*/array( /*#__PURE__*/object({
    actor: /*#__PURE__*/string(),
    permission: /*#__PURE__*/string()
  })),
  data: /*#__PURE__*/any(),
  hex_data: /*#__PURE__*/string().optional()
});
var transactionExtensionsParser = /*#__PURE__*/array(number().or(string())).optional();
var rawTransactionParser = /*#__PURE__*/object({
  expiration: /*#__PURE__*/string(),
  ref_block_num: /*#__PURE__*/number(),
  ref_block_prefix: /*#__PURE__*/number(),
  max_net_usage_words: /*#__PURE__*/number(),
  max_cpu_usage_ms: /*#__PURE__*/number(),
  delay_sec: /*#__PURE__*/number(),
  context_free_actions: /*#__PURE__*/array(actionParser),
  transaction_extensions: /*#__PURE__*/array(transactionExtensionsParser)
});
var baseActionParser = function baseActionParser(contract, action, data) {
  return object({
    account: contract === '*' ? accountParser : literal(contract),
    name: literal(action),
    data: object(data),
    authorization: authorizationsParser
  });
};
var baseActionSerializedParser = function baseActionSerializedParser(contract, action, data) {
  return object({
    account: contract === '*' ? accountParser : literal(contract),
    name: literal(action),
    data: string().or(object(data)),
    authorization: authorizationsParser
  });
};
var webauthActionParser = function webauthActionParser(contract, action, data) {
  return object({
    account: literal('webauthn'),
    name: literal('exec'),
    data: object({
      account: accountParser,
      key: object({
        key: array(string().or(object({
          modulus: string(),
          exponent: string()
        }))),
        user_presence: number(),
        rpid: string()
      }),
      nonce: number(),
      permissions: authorizationsParser,
      signature: object({
        auth_data: string(),
        client_json: string(),
        signature: string()
      }),
      trx: rawTransactionParser.merge(object({
        actions: array(baseActionSerializedParser(contract, action, data)).length(1)
      }))
    }),
    authorization: authorizationsParser
  });
};
var singleActionTransactionParser = function singleActionTransactionParser(contract, action, data) {
  var baseAction = baseActionParser(contract, action, data);
  var webauthAction = webauthActionParser(contract, action, data);
  return rawTransactionParser.merge(object({
    actions: array(baseAction.or(webauthAction)).length(1)
  }));
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var WRAP_CONTRACT = 'proton.wrap';
var WRAP_AUTH_ACTION = 'generateauth';
var FEE_FACTOR = 10000;
var initializeConstants = function initializeConstants(chain) {
  var _initializeCoins = initializeCoins(chain),
      swapCoins = _initializeCoins.swapCoins,
      bridgeCoins = _initializeCoins.bridgeCoins,
      allEnabledCoins = _initializeCoins.allEnabledCoins,
      allCoins = _initializeCoins.allCoins,
      lendCoins = _initializeCoins.lendCoins,
      borrowCoins = _initializeCoins.borrowCoins,
      loanCoins = _initializeCoins.loanCoins;

  var constants = {
    SWAP_CONTRACT: 'proton.swaps',
    DEX_CONTRACT: 'dex',
    FEE_FACTOR: FEE_FACTOR,
    GOOGLE_MAPS_KEY: 'AIzaSyDb2_CrK032kSIqBXbkdwmaLKWELl0SxVs',
    SWAP_URL: chain === 'proton' ? 'https://otc.protonswap.com' : 'https://otc-test.protonswap.com',
    WRAP_SERVER_URL: chain === 'proton' ? 'https://www.api.bloks.io/proton-wrap-public2' : 'https://www.api.bloks.io/proton-wrap-testnet-public2',
    WRAP_CONTRACT: WRAP_CONTRACT,
    WRAP_ACTIONS: {
      SAVE_ADDRESS: 'saveaddress2',
      DELETE_ADDRESS: 'deladdress2',
      WRAP_START: 'wrapstart2',
      WRAP_FINISH: 'wrapfinish2',
      WRAP_PROCESS: 'wrapprocess2',
      WRAP_SET_CONF: 'wrapsetconf2'
    },
    WRAP_TABLES: {
      ADDRESSES: 'addresses2',
      WRAPS: 'wraps2'
    },
    ADDRESSES_INDEXES: {
      BY_ACCOUNT: 2,
      BY_ADDR_HASH: 3
    },
    WRAPS_INDEXES: {
      BY_ACCOUNT: 2,
      BY_STATUS: 3,
      BY_WRAP_HASH: 4
    },
    WRAP_PROCESS_TIMER: 5000,
    FARM_CONTRACT: 'yield.farms',
    WEBHOOK_PERMISSION: 'webhook',
    PUBLIC_PERMISSION: 'public',
    LIGHT_PERMISSION: 'light',
    WRAP_AUTH_ACTION: WRAP_AUTH_ACTION,
    METAL_ENDPOINT: chain === 'proton' ? 'https://cirrus.metalpay.com' : 'https://cirrus-dev.metalpay.com',
    METAL_PROTON_ENDPOINT: chain === 'proton' ? 'https://api.protonchain.com' : 'https://api-dev.protonchain.com',
    METAL_DEX_HTTP_ENDPOINT: chain === 'proton' ? 'https://metallicus-dbapi-dev01.binfra.one/dex' : 'https://metallicus-dbapi-dev01.binfra.one/dex',
    METAL_DEX_WS_ENDPOINT: chain === 'proton' ? 'wss://metallicus-dbapi-dev01.binfra.one/dexws' : 'wss://metallicus-dbapi-dev01.binfra.one/dexws',
    PROTON_ENDPOINTS: chain === 'proton' ? ['https://metal-proton-rpc.global.binfra.one', 'https://proton.greymass.com', 'https://proton.eoscafeblock.com', 'https://proton.cryptolions.io', 'https://proton.eosusa.news'] : ['https://metal-protontest-rpc.global.binfra.one', 'https://testnet.protonchain.com'],
    CHAIN_ID: chain === 'proton' ? '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0' : '71ee83bcf52142d61019d95f9cc5427ba6a0d7ff8accd9e2088ae2abeaf3d3dd',
    DEX_PROCESS_SIZE: 30,
    DEX_SLTPPROCESS_SIZE: 10,
    MAX_PRICE: "9223372036854775806",
    MIN_PRICE: 1,
    CHAIN: chain,
    SWAP_COINS: swapCoins,
    BRIDGE_COINS: bridgeCoins,
    ALL_ENABLED_COINS: allEnabledCoins,
    LEND_COINS: lendCoins,
    BORROW_COINS: borrowCoins,
    LOAN_COINS: loanCoins,
    ALL_COINS: allCoins,
    findBridgeCoinWalletByXtokenAndChain: function findBridgeCoinWalletByXtokenAndChain(xtokenSymbol, chain) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.xtokenSymbol === xtokenSymbol;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.chain === chain;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinWallet: function findBridgeCoinWallet(coin, wallet) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.wallet === wallet;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    },
    findBridgeCoinNetwork: function findBridgeCoinNetwork(coin, network) {
      var bridgeCoin = constants.BRIDGE_COINS.find(function (bridgeCoin) {
        return bridgeCoin.coin === coin;
      });
      if (!bridgeCoin) return undefined;
      var bridgeWallet = bridgeCoin.wallets.find(function (bridgeWallet) {
        return bridgeWallet.network === network;
      });
      if (!bridgeWallet) return undefined;
      return _extends({}, bridgeCoin, bridgeWallet);
    }
  };
  return constants;
};

var createAbstractAuthParser = function createAbstractAuthParser(contract, action, data) {
  return object({
    signer: authorizationParser,
    signatures: array(string()).length(1),
    transaction: singleActionTransactionParser(contract, action, data)
  });
};
var generateAuthData = {
  time: /*#__PURE__*/string(),
  protonAccount: /*#__PURE__*/string()
};
var generateAuthParser = /*#__PURE__*/createAbstractAuthParser(WRAP_CONTRACT, WRAP_AUTH_ACTION, generateAuthData);

var addressParser = /*#__PURE__*/object({
  index: /*#__PURE__*/number(),
  account: accountParser,
  chain: /*#__PURE__*/string(),
  address: /*#__PURE__*/string(),
  address_hash: /*#__PURE__*/string()
});
var generateAddressBodyParser = /*#__PURE__*/object({
  coin: string(),
  wallet: string()
}).merge(generateAuthParser);
var generateAddressResponse = /*#__PURE__*/object({
  id: /*#__PURE__*/string(),
  address: /*#__PURE__*/string(),
  coin: /*#__PURE__*/string(),
  wallet: /*#__PURE__*/string(),
  memo: /*#__PURE__*/string().optional()
});

var rateParser = /*#__PURE__*/object({
  counterCurrency: /*#__PURE__*/string(),
  price: /*#__PURE__*/number(),
  priceChangePercent: /*#__PURE__*/number(),
  marketCap: /*#__PURE__*/number(),
  volume: /*#__PURE__*/number(),
  timestamp: /*#__PURE__*/number()
});
var exchangeRateParser = /*#__PURE__*/object({
  contract: /*#__PURE__*/string(),
  symbol: /*#__PURE__*/string(),
  rank: /*#__PURE__*/number(),
  rates: /*#__PURE__*/array(rateParser)
});
var exchangeRatesParser = /*#__PURE__*/array(exchangeRateParser);
var bloksRatesParser = /*#__PURE__*/array( /*#__PURE__*/object({
  contract: /*#__PURE__*/string(),
  symbol: /*#__PURE__*/string(),
  rank: /*#__PURE__*/number(),
  rates: /*#__PURE__*/array(rateParser)
}));

var Type;

(function (Type) {
  Type["RECEIVE"] = "receive";
  Type["SEND"] = "send";
})(Type || (Type = {}));

var depositBodyParser = /*#__PURE__*/object({
  id: /*#__PURE__*/string(),
  type: /*#__PURE__*/nativeEnum(Type),
  hash: /*#__PURE__*/string(),
  coin: /*#__PURE__*/string(),
  wallet: /*#__PURE__*/string(),
  network: /*#__PURE__*/string().optional() // "erc29"

});
var transactionParser = /*#__PURE__*/object({
  id: /*#__PURE__*/string(),
  wallet: /*#__PURE__*/string(),
  value: /*#__PURE__*/number(),
  valueString: /*#__PURE__*/string(),
  address: /*#__PURE__*/string(),
  type: /*#__PURE__*/nativeEnum(Type),
  state: /*#__PURE__*/string(),
  confirmations: /*#__PURE__*/number(),
  hash: /*#__PURE__*/string(),
  blockHash: /*#__PURE__*/string().optional().nullable(),
  blockHeight: /*#__PURE__*/number().optional().nullable() // 643159

});

var otcOrderResponseParser = /*#__PURE__*/object({
  success: /*#__PURE__*/boolean(),
  transaction_id: /*#__PURE__*/string(),
  errormsg: /*#__PURE__*/string().optional()
});
var otcQuoteBodyParser = /*#__PURE__*/object({
  baseAmount: /*#__PURE__*/number(),
  baseSymbol: /*#__PURE__*/string(),
  quoteSymbol: /*#__PURE__*/string()
});
var otcQuoteResponseParser = /*#__PURE__*/object({
  success: /*#__PURE__*/boolean(),
  token: /*#__PURE__*/string(),
  qty: /*#__PURE__*/number(),
  errormsg: /*#__PURE__*/string().optional()
});

var withdrawData = {
  from: /*#__PURE__*/string().refine(function (val) {
    return val !== WRAP_CONTRACT;
  }, {
    message: WRAP_CONTRACT + " must be receiver"
  }),
  to: /*#__PURE__*/literal(WRAP_CONTRACT),
  quantity: /*#__PURE__*/string(),
  memo: /*#__PURE__*/string()
};
var withdrawBodyParser = /*#__PURE__*/object({
  signer: authorizationParser,
  signatures: /*#__PURE__*/array(string()).length(1),
  transaction: /*#__PURE__*/singleActionTransactionParser('*', 'transfer', withdrawData),
  quoteId: /*#__PURE__*/string(),
  provider: /*#__PURE__*/string().optional()
});
var withdrawMetalResponseParser = /*#__PURE__*/object({
  success: /*#__PURE__*/boolean(),
  id: /*#__PURE__*/string()
});
var withdrawalFeeQuoteParser = /*#__PURE__*/object({
  quoteId: /*#__PURE__*/string(),
  estimatedFee: /*#__PURE__*/string(),
  currency: /*#__PURE__*/string(),
  network: /*#__PURE__*/string()
});

var withdrawHistoryMetalSwapParser = /*#__PURE__*/object({
  id: /*#__PURE__*/string(),
  status: /*#__PURE__*/string(),
  amount: /*#__PURE__*/string(),
  currency: /*#__PURE__*/string(),
  network: /*#__PURE__*/string(),
  created: /*#__PURE__*/string(),
  withdrawalAddress: /*#__PURE__*/string(),
  withdrawalHash: /*#__PURE__*/string().optional()
});
var withdrawHistoryMetalResponseParser = /*#__PURE__*/object({
  swaps: /*#__PURE__*/array(withdrawHistoryMetalSwapParser),
  page: /*#__PURE__*/number(),
  pageSize: /*#__PURE__*/number(),
  numberOfElements: /*#__PURE__*/number(),
  totalPages: /*#__PURE__*/number(),
  totalElements: /*#__PURE__*/number()
});

var Status;

(function (Status) {
  Status["PENDING"] = "pending";
  Status["SUCCESS"] = "success";
  Status["FAIL"] = "fail";
  Status["PROCESSING"] = "processing";
})(Status || (Status = {}));

var wrapStartParser = /*#__PURE__*/object({
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/string(),
  txid: /*#__PURE__*/string(),
  chain: /*#__PURE__*/string(),
  deposit_address: /*#__PURE__*/string(),
  confirmations: /*#__PURE__*/number()
});
var wrapSetConfParser = /*#__PURE__*/object({
  wrap_hash: /*#__PURE__*/string(),
  confirmations: /*#__PURE__*/number()
});
var wrapParser = /*#__PURE__*/object({
  index: /*#__PURE__*/number(),
  proton_account: /*#__PURE__*/string(),
  balance: ExtendedAssetParser,
  id: /*#__PURE__*/string(),
  txid: /*#__PURE__*/string(),
  chain: /*#__PURE__*/string(),
  deposit_address: /*#__PURE__*/string(),
  status: /*#__PURE__*/nativeEnum(Status),
  finish_txid: /*#__PURE__*/string(),
  wrap_hash: /*#__PURE__*/string(),
  confirmations: /*#__PURE__*/number()
});

var _TOPICS;
var numTransform = /*#__PURE__*/string().regex(/\d+/).transform(Number);
var ohlcvParser = /*#__PURE__*/object({
  time: /*#__PURE__*/number(),
  open: /*#__PURE__*/number(),
  high: /*#__PURE__*/number(),
  low: /*#__PURE__*/number(),
  close: /*#__PURE__*/number(),
  volume: /*#__PURE__*/number(),
  volume_bid: /*#__PURE__*/number(),
  count: /*#__PURE__*/number()
});
var getOhlcvParser = /*#__PURE__*/object({
  interval: /*#__PURE__*/string(),
  dateFrom: /*#__PURE__*/string(),
  dateTo: /*#__PURE__*/string(),
  marketId: /*#__PURE__*/number().or(numTransform),
  limit: /*#__PURE__*/number().or(numTransform)["default"](500).refine(function (n) {
    return n <= 1000;
  }, 'Max limit is 1000')
});
var getOhlcvResponseParser = /*#__PURE__*/object({
  sync: /*#__PURE__*/number(),
  data: /*#__PURE__*/array(ohlcvParser)
});
var orderHistoryParser = /*#__PURE__*/object({
  seq: /*#__PURE__*/number(),
  block_num: /*#__PURE__*/number(),
  block_time: /*#__PURE__*/string(),
  order_id: /*#__PURE__*/number(),
  market_id: /*#__PURE__*/number(),
  quantity_init: /*#__PURE__*/number().optional(),
  quantity_curr: /*#__PURE__*/number(),
  price: /*#__PURE__*/number(),
  account_name: /*#__PURE__*/string(),
  order_side: /*#__PURE__*/number(),
  order_type: /*#__PURE__*/number(),
  trigger_price: /*#__PURE__*/number(),
  fill_type: /*#__PURE__*/number(),
  status: /*#__PURE__*/string(),
  quantity_change: /*#__PURE__*/number(),
  trx_id: /*#__PURE__*/string()
});
var getOrderHistoryParser = /*#__PURE__*/object({
  account: /*#__PURE__*/string(),
  marketId: /*#__PURE__*/number().or(numTransform).optional(),
  offset: /*#__PURE__*/number().or(numTransform)["default"](0),
  limit: /*#__PURE__*/number().or(numTransform)["default"](100).refine(function (n) {
    return n <= 250;
  }, 'Max limit is 250')
});
var getOrderHistoryResponseParser = /*#__PURE__*/object({
  sync: /*#__PURE__*/number(),
  count: /*#__PURE__*/number(),
  data: /*#__PURE__*/array(orderHistoryParser)
});
var depthParser = /*#__PURE__*/object({
  level: /*#__PURE__*/number(),
  ask: /*#__PURE__*/number(),
  bid: /*#__PURE__*/number(),
  count: /*#__PURE__*/number()
});
var getDepthParser = /*#__PURE__*/object({
  marketId: /*#__PURE__*/string(),
  step: /*#__PURE__*/string(),
  limit: /*#__PURE__*/number().or(numTransform)["default"](100).refine(function (n) {
    return n <= 250;
  }, 'Max limit is 250')
});
var getDepthResponseParser = /*#__PURE__*/object({
  sync: /*#__PURE__*/number(),
  data: /*#__PURE__*/object({
    bids: /*#__PURE__*/array(depthParser),
    asks: /*#__PURE__*/array(depthParser)
  })
});
var dailyParser = /*#__PURE__*/object({
  market_id: /*#__PURE__*/number(),
  first: /*#__PURE__*/number(),
  last: /*#__PURE__*/number(),
  bid: /*#__PURE__*/number(),
  ask: /*#__PURE__*/number(),
  change_percentage_24hr: /*#__PURE__*/number()
});
var getDailyResponseParser = /*#__PURE__*/object({
  sync: /*#__PURE__*/number(),
  data: /*#__PURE__*/array(dailyParser)
});
var tradeParser = /*#__PURE__*/object({
  block_num: /*#__PURE__*/number(),
  block_time: /*#__PURE__*/string(),
  trade_id: /*#__PURE__*/number(),
  market_id: /*#__PURE__*/number(),
  price: /*#__PURE__*/number(),
  bid_user: /*#__PURE__*/string(),
  bid_user_order_id: /*#__PURE__*/number(),
  bid_total: /*#__PURE__*/number(),
  bid_amount: /*#__PURE__*/number(),
  bid_fee: /*#__PURE__*/number(),
  ask_user: /*#__PURE__*/string(),
  ask_user_order_id: /*#__PURE__*/number(),
  ask_total: /*#__PURE__*/number(),
  ask_amount: /*#__PURE__*/number(),
  ask_fee: /*#__PURE__*/number(),
  order_side: /*#__PURE__*/number(),
  trx_id: /*#__PURE__*/string()
});
var getTradesParser = /*#__PURE__*/object({
  marketId: /*#__PURE__*/number().or(numTransform),
  offset: /*#__PURE__*/number().or(numTransform)["default"](0),
  limit: /*#__PURE__*/number().or(numTransform)["default"](100).refine(function (n) {
    return n <= 250;
  }, 'Max limit is 250')
});
var getTradesResponseParser = /*#__PURE__*/object({
  sync: /*#__PURE__*/number(),
  data: /*#__PURE__*/array(tradeParser)
});
var syncParser = /*#__PURE__*/object({
  sourceid: /*#__PURE__*/number(),
  block_num: /*#__PURE__*/string(),
  block_time: /*#__PURE__*/string(),
  irreversible: /*#__PURE__*/string(),
  is_master: /*#__PURE__*/number(),
  last_updated: /*#__PURE__*/string()
});
var getSyncResponseParser = /*#__PURE__*/object({
  dbSecondsBehind: /*#__PURE__*/number(),
  chronicleSecondsBehind: /*#__PURE__*/number(),
  maxSecondsBehind: /*#__PURE__*/number()
});
var orderType;

(function (orderType) {
  orderType[orderType["ORDERBOOK"] = 0] = "ORDERBOOK";
  orderType[orderType["LIMIT"] = 1] = "LIMIT";
  orderType[orderType["STOPLOSS"] = 2] = "STOPLOSS";
  orderType[orderType["TAKEPROFIT"] = 3] = "TAKEPROFIT";
})(orderType || (orderType = {}));

var orderSide;

(function (orderSide) {
  orderSide[orderSide["INVALID"] = 0] = "INVALID";
  orderSide[orderSide["BUY"] = 1] = "BUY";
  orderSide[orderSide["SELL"] = 2] = "SELL";
})(orderSide || (orderSide = {}));

var fillType;

(function (fillType) {
  fillType[fillType["GTC"] = 0] = "GTC";
  fillType[fillType["IOC"] = 1] = "IOC";
  fillType[fillType["POST_ONLY"] = 2] = "POST_ONLY";
})(fillType || (fillType = {}));

var logStatus;

(function (logStatus) {
  logStatus["CREATE"] = "create";
  logStatus["UPDATE"] = "update";
  logStatus["TRANSFER"] = "transfer";
  logStatus["CANCEL"] = "cancel";
  logStatus["DELETE"] = "delete";
})(logStatus || (logStatus = {}));

var ITopics;

(function (ITopics) {
  ITopics["TRADES"] = "TRADES";
  ITopics["ORDERS"] = "ORDERS";
})(ITopics || (ITopics = {}));

var TOPICS = (_TOPICS = {}, _TOPICS[ITopics.TRADES] = {
  topic: ITopics.TRADES
}, _TOPICS[ITopics.ORDERS] = {
  topic: ITopics.ORDERS
}, _TOPICS);

var loginAccountParamsV3Parser = /*#__PURE__*/object({
  email: string().optional(),
  verificationCode: string().optional()
}).merge(generateAuthParser);

var isSameToken = function isSameToken(token1, token2) {
  return token1.xtokenSymbol === token2.xtokenSymbol && token1.xtokenPrecision === token2.xtokenPrecision && token1.xtokenContract === token2.xtokenContract;
};
var median = function median(numbers) {
  var sorted = numbers.slice().sort(function (a, b) {
    return a - b;
  });
  var middle = Math.floor(sorted.length / 2);

  if (sorted.length % 2 === 0) {
    return (sorted[middle - 1] + sorted[middle]) / 2;
  }

  return sorted[middle];
};

var INode = function INode(key, data) {
  this.key = void 0;
  this.data = {};
  this.key = key;

  if (data) {
    this.data = data;
  }
};
var ILink = function ILink(from, to, data) {
  this.from = void 0;
  this.to = void 0;
  this.data = {};
  this.from = from;
  this.to = to;

  if (data) {
    this.data = data;
  }
};
var Graph = /*#__PURE__*/function () {
  function Graph() {
    this.nodes = [];
    this.links = [];
    this.lastPathFound = [];

    this.isEquals = function (a, b) {
      return a.key === b.key;
    };
  }

  var _proto = Graph.prototype;

  _proto.addNode = function addNode(k, v) {
    var node = this.findNode(k);

    if (!node) {
      this.nodes.push(new INode(k, v));
    }
  };

  _proto.addNodes = function addNodes() {
    var _this = this;

    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    nodes.forEach(function (node) {
      return typeof node === "string" ? _this.addNode(node) : _this.addNode(node[0], node[1]);
    });
  };

  _proto.findNode = function findNode(k) {
    var _this2 = this;

    var inode = new INode(k);
    return this.nodes.find(function (node) {
      return _this2.isEquals(node, inode);
    });
  };

  _proto.findNodes = function findNodes() {
    var _this3 = this;

    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    return keys.map(function (k) {
      return _this3.findNode(k);
    });
  };

  _proto.requireFindNodes = function requireFindNodes() {
    var nodes = this.findNodes.apply(this, arguments);

    if (nodes.some(function (n) {
      return n === undefined;
    })) {
      throw new Error('One of the nodes does not exist');
    }

    return nodes;
  };

  _proto.addLink = function addLink(nodeA, nodeB, data) {
    var _this$requireFindNode = this.requireFindNodes(nodeA, nodeB),
        inodeA = _this$requireFindNode[0],
        inodeB = _this$requireFindNode[1];

    this.links.push(new ILink(inodeA, inodeB, data));
  };

  _proto.addLinks = function addLinks() {
    var _this4 = this;

    for (var _len3 = arguments.length, links = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      links[_key3] = arguments[_key3];
    }

    links.forEach(function (link) {
      return _this4.addLink.apply(_this4, link);
    });
  }
  /**
   * Get all nodes linked
   * to from `node`.
   */
  ;

  _proto.findLinkedNodes = function findLinkedNodes(node) {
    var _this5 = this;

    return this.links.reduce(function (acc, link) {
      if (_this5.isEquals(link.from, node)) {
        acc.push(link.to);
      }

      return acc;
    }, []);
  };

  _proto.findAllPaths = function findAllPaths(from, to) {
    var _this6 = this;

    var allPaths = [];

    var _this$requireFindNode2 = this.requireFindNodes(from, to),
        fromNode = _this$requireFindNode2[0],
        toNode = _this$requireFindNode2[1];

    var path = [fromNode];
    var seen = new Set();

    var stuck = function stuck(x) {
      if (_this6.isEquals(x, toNode)) {
        return false;
      }

      for (var _iterator = _createForOfIteratorHelperLoose(_this6.findLinkedNodes(x)), _step; !(_step = _iterator()).done;) {
        var y = _step.value;

        if (!seen.has(y.key)) {
          seen.add(y.key);

          if (!stuck(y)) {
            return false;
          }
        }
      }

      return true;
    };

    var search = function search(x) {
      if (_this6.isEquals(x, toNode)) {
        allPaths.push(cloneDeep(path));
        return;
      }

      seen = new Set(path.map(function (p) {
        return p.key;
      }));

      if (stuck(x)) {
        return;
      }

      for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.findLinkedNodes(x)), _step2; !(_step2 = _iterator2()).done;) {
        var y = _step2.value;

        if (!path.includes(y)) {
          path.push(y);
          search(y);
          path.pop();
        }
      }
    };

    search(fromNode);
    return allPaths;
  };

  return Graph;
}();

/**
 * XPR<>XUSDT (XPR -> XUSDT)
 *
 *                     pool1 * pool2
 *  term =  pool2  -  --------------
 *                     pool1 + swap
 *
 *  result = term - (term * fee)
 */

var compute_transfer = function compute_transfer(pool1, pool2, swap, exchange_fee, precision) {
  var term1 = pool2;
  var term2over = pool1.times(pool2);
  var term2under = pool1.plus(swap);
  var term2 = term2over.div(term2under).integerValue(BigNumber.ROUND_DOWN);
  var term = term1.minus(term2);
  var fee = new BigNumber(exchange_fee).div(FEE_FACTOR);
  var result = term.minus(term.times(fee));
  return result.integerValue(BigNumber.ROUND_DOWN).shiftedBy(-precision);
};
var compute_transfer_curve = function compute_transfer_curve(reserve_in, reserve_out, amount_in, exchange_fee, precision, amplifier) {
  if (amplifier === 0) {
    return compute_transfer(new BigNumber(reserve_in), new BigNumber(reserve_out), new BigNumber(amount_in), exchange_fee, precision);
  }

  var MAX_ITERATIONS = 10;
  var sum = reserve_in + reserve_out;
  var D = sum;
  var D_prev = 0;

  var F = function F(v) {
    return (v >= 0 ? 1 : -1) * Math.floor(Math.abs(v));
  };

  var i = MAX_ITERATIONS;

  while (D != D_prev && i--) {
    var prod1 = F(F(D * D / (reserve_in * 2)) * D / (reserve_out * 2));
    D_prev = D;
    D = F(2 * D * (amplifier * sum + prod1) / ((2 * amplifier - 1) * D + 3 * prod1));
  }

  var b = reserve_in + amount_in + F(D / (amplifier * 2)) - D;
  var c = F(F(D * D / ((reserve_in + amount_in) * 2)) * D / (amplifier * 4));
  var x = D,
      x_prev = 0;
  i = MAX_ITERATIONS;

  while (x != x_prev && i--) {
    x_prev = F(x);
    x = +new BigNumber(x * x + c).div(2 * x + b).toFixed(0, BigNumber.ROUND_DOWN);
  }

  if (reserve_out <= x) {
    throw new Error("curve: insufficient reserve out");
  } // Amount out + Fee + 1


  var amount_out_with_fee = new BigNumber(reserve_out - x); // Fee + 1
  // +1 covers small precision issues

  var fee = amount_out_with_fee.times(exchange_fee).div(FEE_FACTOR).plus(1).toFixed(0, BigNumber.ROUND_DOWN); // Amount out

  var amount_out = amount_out_with_fee.minus(fee);
  return amount_out.integerValue(BigNumber.ROUND_DOWN).shiftedBy(-precision);
};
var compute_liquidity = function compute_liquidity(amount_lt, pool, lt_supply, precision) {
  var over = amount_lt.times(pool);
  var under = lt_supply;
  var result = over.div(under).integerValue(BigNumber.ROUND_DOWN);
  return +result.shiftedBy(-precision).toFixed(precision, BigNumber.ROUND_DOWN);
};
var isInputInvalid = function isInputInvalid(data, value, pool) {
  value = String(value);
  var isBackspace = data === null;
  var isNumber = !/[0-9]|\./.test(data);
  var isDoubleDot = data === '.' && value.indexOf('.') !== value.length - 1;
  var isPrecisionTooHigh = value && value.indexOf('.') !== -1 && value.split('.')[1].length > pool.xtokenPrecision;
  var isInvalid = !isBackspace && Boolean(isNumber || isDoubleDot || isPrecisionTooHigh);
  return isInvalid;
};
var applyDiscountToFee = function applyDiscountToFee(fee, staked) {
  if (staked >= 10000000) {
    return fee * 0;
  } else if (staked >= 1000000) {
    return fee * 0.33;
  } else if (staked >= 100000) {
    return fee * 0.66;
  } else {
    return fee;
  }
};

export { Chains, ExtendedAssetParser, FEE_FACTOR, Graph, ILink, INode, ITopics, Networks, Providers, Status, TOPICS, Type, WRAP_AUTH_ACTION, WRAP_CONTRACT, accountParser, addressParser, applyDiscountToFee, authorizationParser, authorizationsParser, baseActionParser, baseActionSerializedParser, bloksRatesParser, compute_liquidity, compute_transfer, compute_transfer_curve, createAbstractAuthParser, dailyParser, depositBodyParser, depthParser, exchangeRateParser, exchangeRatesParser, explorerLinkByChain, fillType, generateAddressBodyParser, generateAddressResponse, generateAuthParser, getDailyResponseParser, getDepthParser, getDepthResponseParser, getOhlcvParser, getOhlcvResponseParser, getOrderHistoryParser, getOrderHistoryResponseParser, getSyncResponseParser, getTradesParser, getTradesResponseParser, initializeCoins, initializeConstants, isInputInvalid, isSameToken, logStatus, loginAccountParamsV3Parser, median, ohlcvParser, orderHistoryParser, orderSide, orderType, otcOrderResponseParser, otcQuoteBodyParser, otcQuoteResponseParser, protonExplorerTxUrl, rateParser, similarChains, singleActionTransactionParser, syncParser, tradeParser, transactionParser, webauthActionParser, withdrawBodyParser, withdrawHistoryMetalResponseParser, withdrawHistoryMetalSwapParser, withdrawMetalResponseParser, withdrawalFeeQuoteParser, wrapParser, wrapSetConfParser, wrapStartParser };
//# sourceMappingURL=wrap-constants.esm.js.map
