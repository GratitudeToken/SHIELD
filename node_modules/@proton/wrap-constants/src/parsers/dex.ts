import { ExtendedAsset, ExtendedSymbol } from '@bloks/numbers';
import * as z from 'zod';

const numTransform = z.string().regex(/\d+/).transform(Number)

export const ohlcvParser = z.object({
  time: z.number(),
  open: z.number(),
  high: z.number(),
  low: z.number(),
  close: z.number(),
  volume: z.number(),
  volume_bid: z.number(),
  count: z.number()
})
export type OHLCV = z.infer<typeof ohlcvParser>

export const getOhlcvParser = z.object({
  interval: z.string(),
  dateFrom: z.string(),
  dateTo: z.string(),
  marketId: z.number().or(numTransform),
  limit: z.number().or(numTransform).default(500).refine(n => n <= 1000, 'Max limit is 1000'),
})
export type GetOHLCV = z.infer<typeof getOhlcvParser>

export const getOhlcvResponseParser = z.object({
  sync: z.number(),
  data: z.array(ohlcvParser)
})
export type GetOHLCVResponse = z.infer<typeof getOhlcvResponseParser>

export const orderHistoryParser = z.object({
  seq: z.number(),
  block_num: z.number(),
  block_time: z.string(),
  order_id: z.number(),
  market_id: z.number(),
  quantity_init: z.number().optional(),
  quantity_curr: z.number(),
  price: z.number(),
  account_name: z.string(),
  order_side: z.number(),
  order_type: z.number(),
  trigger_price: z.number(),
  fill_type: z.number(),
  status: z.string(),
  quantity_change: z.number(),
  trx_id: z.string(),
})
export type OrderHistory = z.infer<typeof orderHistoryParser>

export const getOrderHistoryParser = z.object({
  account: z.string(),
  marketId: z.number().or(numTransform).optional(),
  offset: z.number().or(numTransform).default(0),
  limit: z.number().or(numTransform).default(100).refine(n => n <= 250, 'Max limit is 250'),
})
export type GetOrderHistory = z.infer<typeof getOrderHistoryParser>

export const getOrderHistoryResponseParser = z.object({
  sync: z.number(),
  count: z.number(),
  data: z.array(orderHistoryParser)
})
export type GetOrderHistoryResponse = z.infer<typeof getOrderHistoryResponseParser>

export const depthParser = z.object({
  level: z.number(),
  ask: z.number(),
  bid: z.number(),
  count: z.number(),
})
export type Depth = z.infer<typeof depthParser>

export const getDepthParser = z.object({
  marketId: z.string(),
  step: z.string(),
  limit: z.number().or(numTransform).default(100).refine(n => n <= 250, 'Max limit is 250'),
})
export type GetDepth = z.infer<typeof getDepthParser>

export const getDepthResponseParser = z.object({
  sync: z.number(),
  data: z.object({
    bids: z.array(depthParser),
    asks: z.array(depthParser),
  })
})
export type GetDepthResponse = z.infer<typeof getDepthResponseParser>

export const dailyParser = z.object({
  market_id: z.number(),
  first: z.number(),
  last: z.number(),
  bid: z.number(),
  ask: z.number(),
  change_percentage_24hr: z.number()
})
export type Daily = z.infer<typeof dailyParser>

export const getDailyResponseParser = z.object({
  sync: z.number(),
  data: z.array(dailyParser)
})
export type GetDailyResponseParser = z.infer<typeof getDailyResponseParser>

export const tradeParser = z.object({
  block_num: z.number(),
  block_time: z.string(),
  trade_id: z.number(),
  market_id: z.number(),
  price: z.number(),
  bid_user: z.string(),
  bid_user_order_id: z.number(),
  bid_total: z.number(),
  bid_amount: z.number(),
  bid_fee: z.number(),
  ask_user: z.string(),
  ask_user_order_id: z.number(),
  ask_total: z.number(),
  ask_amount: z.number(),
  ask_fee: z.number(),
  order_side: z.number(),
  trx_id: z.string(),
})
export type Trade = z.infer<typeof tradeParser>

export const getTradesParser = z.object({
  marketId: z.number().or(numTransform),
  offset: z.number().or(numTransform).default(0),
  limit: z.number().or(numTransform).default(100).refine(n => n <= 250, 'Max limit is 250'),
})
export type GetTrades = z.infer<typeof getTradesParser>

export const getTradesResponseParser = z.object({
  sync: z.number(),
  data: z.array(tradeParser)
})
export type GetTradesResponseParser = z.infer<typeof getTradesResponseParser>

export const syncParser = z.object({
  sourceid: z.number(),
  block_num: z.string(),
  block_time: z.string(),
  irreversible: z.string(),
  is_master: z.number(),
  last_updated: z.string(),
})
export type Sync = z.infer<typeof syncParser>

export const getSyncResponseParser = z.object({
  dbSecondsBehind: z.number(),
  chronicleSecondsBehind: z.number(),
  maxSecondsBehind: z.number()
})
export type GetSyncResponse = z.infer<typeof getSyncResponseParser>

export enum orderType { ORDERBOOK = 0, LIMIT = 1, STOPLOSS = 2, TAKEPROFIT = 3 }

export enum orderSide { INVALID = 0, BUY = 1, SELL = 2 }

export enum fillType { GTC = 0, IOC = 1, POST_ONLY = 2 }

export enum logStatus {
    CREATE = "create",
    UPDATE = "update",
    TRANSFER = "transfer",
    CANCEL = "cancel",
    DELETE = "delete",
}

export interface CurrentOrder {
  order_id: number
  market_id: number
  quantity_init: number
  quantity_curr: number
  price: number
  account_name: string
  order_side: number
  order_type: number
  status: string
  created_at: string
  updated_at: string
}

export interface RawMarket {
    market_id: number
    order_min: number
    status_code: number
    maker_fee: number
    taker_fee: number
    bid_token: {
        sym: string
        contract: string
    }
    ask_token: {
        quantity: string
        contract: string
    }
}

export interface Market {
    market_id: number
    order_min: number
    status_code: number
    maker_fee: number
    taker_fee: number
    bid_token: ExtendedSymbol
    ask_token: ExtendedAsset
    bid_multiplier: number
    ask_multiplier: number
}

export interface DbMarket {
  market_id: number
  order_min: number
  status_code: number
  maker_fee: number
  taker_fee: number
  bid_token_c: string
  bid_token_s: string
  bid_token_m: number
  ask_token_c: string
  ask_token_s: string
  ask_token_m: number
  created_at: string
  updated_at: string
}

export enum ITopics {
  TRADES = "TRADES",
  ORDERS = "ORDERS",
}
  
export const TOPICS = {
  [ITopics.TRADES]: {
    topic: ITopics.TRADES,
  },
  [ITopics.ORDERS]: {
    topic: ITopics.ORDERS,
  }
}