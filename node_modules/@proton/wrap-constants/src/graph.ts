import cloneDeep from 'lodash.clonedeep'

export class INode <T> {
    data: T = {} as T
    constructor (public key: string, data?: T) {
        if (data) {
            this.data = data
        }
    }
}

export class ILink <T> {
    data: T = {} as T
    constructor (public from: INode<T>, public to: INode<T>, data?: T) {
        if (data) {
            this.data = data
        }
    }
}

export class Graph <T> {
    nodes: INode<T>[] = []
    links: ILink<T>[] = []
    lastPathFound: INode<T>[] = []

    isEquals = (a: INode<T>, b: INode<T>) => a.key === b.key

    addNode (k: string, v?: T): void {
        const node = this.findNode(k)
        if (!node) {
            this.nodes.push(new INode(k, v))
        }
    }

    addNodes (...nodes: (string | [string, T?])[]): void {
        nodes.forEach(node => typeof node === "string" ? this.addNode(node) : this.addNode(node[0], node[1]))
    }

    findNode (k: string): INode<T> | undefined {
        const inode = new INode<T>(k)
        return this.nodes.find(node => this.isEquals(node, inode))
    }

    findNodes (...keys: string[]): (INode<T> | undefined)[] {
        return keys.map(k => this.findNode(k))
    }

    requireFindNodes (...keys: string[]): INode<T>[] {
        const nodes = this.findNodes(...keys)
        if (nodes.some(n => n === undefined)) {
            throw new Error('One of the nodes does not exist')
        }
        return nodes as INode<T>[]
    }

    addLink (nodeA: string, nodeB: string, data?: T): void {
        const [inodeA, inodeB] = this.requireFindNodes(nodeA, nodeB)
        this.links.push(new ILink<T>(inodeA, inodeB, data))
    }

    addLinks (...links: [nodeA: string, nodeB: string, data?: T][]): void {
        links.forEach(link => this.addLink(...link))
    }
    
    /** 
     * Get all nodes linked 
     * to from `node`.
     */
    findLinkedNodes (node: INode<T>) {
        return this.links.reduce((acc, link) => {
            if (this.isEquals(link.from, node)) {
                acc.push(link.to)
            }
            return acc;
        }, [] as INode<T>[]);
    }

    findAllPaths(from: string, to: string) {
        const allPaths: INode<T>[][] = []

        const [fromNode, toNode] = this.requireFindNodes(from, to)

        const path: INode<T>[] = [fromNode]
        let seen = new Set()

        const stuck = (x: INode<T>) => {
            if (this.isEquals(x, toNode)) {
                return false
            }

            for (const y of this.findLinkedNodes(x)) {
                if (!seen.has(y.key)) {
                    seen.add(y.key)
                    if (!stuck(y)) {
                        return false
                    }
                }
            }

            return true
        }

        const search = (x: INode<T>) => {
            if (this.isEquals(x, toNode)) {
                allPaths.push(cloneDeep(path))
                return
            }
            seen = new Set(path.map(p => p.key))
            if (stuck(x)) {
                return
            }

            for (const y of this.findLinkedNodes(x)) {
                if (!path.includes(y)) {
                    path.push(y)
                    search(y)
                    path.pop()
                }
            }
        }

        search(fromNode)

        return allPaths
    }
}