import { BigNumber as BN } from 'bignumber.js'
import { FEE_FACTOR } from './constants'

/**
 * XPR<>XUSDT (XPR -> XUSDT)
 *
 *                     pool1 * pool2
 *  term =  pool2  -  --------------
 *                     pool1 + swap
 *
 *  result = term - (term * fee)
 */
export const compute_transfer = (pool1: BN.Instance, pool2: BN.Instance, swap: BN.Instance, exchange_fee: number, precision: number): BN => {
  const term1 = pool2
  const term2over = pool1.times(pool2)
  const term2under = pool1.plus(swap)
  const term2 = term2over.div(term2under).integerValue(BN.ROUND_DOWN)
  const term = term1.minus(term2)
  const fee = new BN(exchange_fee).div(FEE_FACTOR)
  const result = term.minus(term.times(fee))
 
  return result.integerValue(BN.ROUND_DOWN).shiftedBy(-precision)
}

export const compute_transfer_curve = (
  reserve_in: number,
  reserve_out: number,
  amount_in: number,
  exchange_fee: number,
  precision: number,
  amplifier: number
): BN => {
  if (amplifier === 0) {
      return compute_transfer(new BN(reserve_in), new BN(reserve_out), new BN(amount_in), exchange_fee, precision)
  }

  const MAX_ITERATIONS = 10

  const sum = reserve_in + reserve_out
  let D = sum;
  let D_prev = 0

  const F = (v: number) => {
      return (v >= 0 ? 1 : -1) * Math.floor(Math.abs(v));
  }

  let i = MAX_ITERATIONS
  while (D != D_prev && i--) {
      const prod1 = F((F((D * D) / (reserve_in * 2)) * D) / (reserve_out * 2));
      D_prev = D
      D = F((2 * D * ((amplifier * sum) + prod1)) / ((2 * amplifier - 1) * D + 3 * prod1));
  }

  const b = ((reserve_in + amount_in) + F(D / (amplifier * 2))) - D;

  const c = F(F((D * D) / ((reserve_in + amount_in) * 2)) * D / (amplifier * 4));

  let x = D, x_prev = 0;
  i = MAX_ITERATIONS;
  while ( x != x_prev && i--) {
    x_prev = F(x);
    x = +new BN(x * x + c).div(2 * x + b).toFixed(0, BN.ROUND_DOWN)
  }

  if (reserve_out <= x) {
      throw new Error("curve: insufficient reserve out")
  }

  // Amount out + Fee + 1
  const amount_out_with_fee = new BN(reserve_out - x);

  // Fee + 1
  // +1 covers small precision issues
  const fee = amount_out_with_fee.times(exchange_fee).div(FEE_FACTOR).plus(1).toFixed(0, BN.ROUND_DOWN);
  
  // Amount out
  const amount_out = amount_out_with_fee.minus(fee)

  return amount_out.integerValue(BN.ROUND_DOWN).shiftedBy(-precision)
}

export const compute_liquidity = (amount_lt: BN.Instance, pool: BN.Instance, lt_supply: BN.Instance, precision: number): number => {
  const over = amount_lt.times(pool)
  const under = lt_supply
  const result = over.div(under).integerValue(BN.ROUND_DOWN)

  return +(result.shiftedBy(-precision).toFixed(precision, BN.ROUND_DOWN))
}

export const isInputInvalid = (data: string, value: string | number, pool: { xtokenPrecision: number }): boolean => {
  value = String(value)
  
  const isBackspace = data === null
  const isNumber = !/[0-9]|\./.test(data)
  const isDoubleDot = data === '.' && value.indexOf('.') !== value.length - 1
  const isPrecisionTooHigh = value && value.indexOf('.') !== -1 && value.split('.')[1].length > pool.xtokenPrecision
  const isInvalid = !isBackspace && Boolean(isNumber || isDoubleDot || isPrecisionTooHigh)

  return isInvalid
}

export const applyDiscountToFee = (fee: number, staked: number): number => {
  if (staked >= 10000000) {
    return fee * 0
  } else if (staked >= 1000000) {
    return fee * 0.33
  } else if (staked >= 100000) {
    return fee * 0.66
  } else {
    return fee
  }
}