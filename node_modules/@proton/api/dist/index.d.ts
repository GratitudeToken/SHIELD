import { RpcInterfaces, JsonRpc, Api } from '@proton/js';
import { constants } from '@bloks/constants';
import * as Hyperion from '@proton/hyperion';
import * as _proton_light_api from '@proton/light-api';
import * as _bloks_utils from '@bloks/utils';
import * as _proton_hyperion_dist_src_types_state_get_proposals from '@proton/hyperion/dist/src/types/state/get_proposals';
import BN from 'bignumber.js';
import * as z from 'zod';
import { ExchangeRates, WithdrawalFeeQuote, LoginAccountParamsV3, OtcQuoteBody, OtcOrderResponse, GenerateAddressBody, WithdrawBody } from '@proton/wrap-constants';

declare function getAccount(this: ApiClass, accountName: string): Promise<RpcInterfaces.GetAccountResult | undefined>;
declare function searchAccount(this: ApiClass, query: string, limit: number): Promise<any[]>;
declare function getGravatar(this: ApiClass, account: string): Promise<any>;
declare function getParent(this: ApiClass, account: string): Promise<unknown>;
declare function getAccountLightData(this: ApiClass, accountName: string): Promise<_proton_light_api.GetAccountInfo | undefined>;

declare function getActionsFromNative(this: ApiClass, accountName: string, actionSkip: number, actionsPerPage: number, historyType?: string): Promise<never[] | _bloks_utils.GetActionsNativeResult>;
declare function getActions(this: ApiClass, accountName: string, historyType: string, { actionsPerPage, actionSkip, sortDirection, dfuseCursorStack, tokenFilter, actionFilters, contractFilter, actionFilter, start, end }?: {
    actionsPerPage: number;
    actionSkip: number;
    sortDirection: string;
    dfuseCursorStack: string[];
    tokenFilter: any;
    actionFilters: any;
    contractFilter: string;
    actionFilter: string;
    start?: string | undefined;
    end: string | undefined;
}): Promise<never[] | _bloks_utils.GetActionsNativeResult | {
    cursor: string;
    actions: any[];
    numOfTxLoaded: number;
} | {
    lib: number;
    actions: {
        action_trace: _bloks_utils.Action;
    }[];
    query_time: number;
    numOfTxLoaded: number;
    total: {
        relation: string;
        value: number;
    };
}>;
declare function getActionsFromDfuse(this: ApiClass, accountName: string, { before, after, limit, cursor, query, direction, tokenFilter, actionFilters, contractFilter, actionFilter, type }?: {
    before: string | undefined;
    after: string | undefined;
    limit: number;
    cursor: string;
    query: string;
    direction: string;
    tokenFilter: any;
    actionFilters: any;
    contractFilter: string;
    actionFilter: string;
    type?: string | undefined;
}): Promise<{
    cursor: string;
    actions: any[];
    numOfTxLoaded: number;
}>;
declare function getActionsFromHyperion(this: ApiClass, account: string, { skip, limit, sort, after, before, filter, tokenFilter, actionFilters, contractFilter, actionFilter, }?: {
    skip: number;
    limit: number;
    sort: string;
    after?: string | undefined;
    before?: string | undefined;
    filter?: string | undefined;
    tokenFilter?: any;
    actionFilters?: any;
    contractFilter?: string | undefined;
    actionFilter?: string | undefined;
}): Promise<{
    lib: number;
    actions: {
        action_trace: _bloks_utils.Action;
    }[];
    query_time: number;
    numOfTxLoaded: number;
    total: {
        relation: string;
        value: number;
    };
}>;

declare function getDappStats(this: ApiClass): Promise<any>;
declare function getDspPackages(this: ApiClass): Promise<any[]>;
declare function getDapphodlBalance(this: ApiClass, account: string): Promise<any>;
declare function getDappBalance(this: ApiClass, account: string): Promise<any>;
declare function getDappStakes(this: ApiClass, account: string): Promise<any[]>;
declare function getDapphodlStakes(this: ApiClass, account: string, lower_bound?: string | number): Promise<any[]>;
declare function getDappUnstakes(this: ApiClass, account: string): Promise<any[]>;
declare function getDapphodlUnstakes(this: ApiClass, account: string): Promise<any[]>;

declare function getFIOPublicKey(this: ApiClass, account: string): Promise<any>;
declare function getFIOVoter(this: ApiClass, account: string): Promise<any>;
declare function getFIOAddressByName(this: ApiClass, name: string): Promise<any>;
declare function getNFTsByFioAddress(this: ApiClass, name: string): Promise<any>;
declare function getFIODomainByName(this: ApiClass, name: string): Promise<any>;
declare function getDomains(this: ApiClass, limit: number | undefined, upper_bound: number): Promise<any[]>;
declare function getAddresses(this: ApiClass, limit: number | undefined, upper_bound: number): Promise<any[]>;
declare function getFIOProducers(this: ApiClass, limit: number): Promise<any[]>;
declare function getFIOBalance(this: ApiClass, fio_public_key: string): Promise<null | {
    balance: number;
    available: number;
    staked: number;
    srps: number;
    roe: string;
}>;
declare function getFIOSupplyBreakdown(this: ApiClass): Promise<{
    supply: number;
    totalLocked: number;
    bpRewards: number;
    bpBucket: number;
    totalBp: number;
    circulating: string;
}>;
declare function getFIOFees(this: ApiClass): Promise<any>;
declare function addFIOFeeToActions(this: ApiClass, actions: any, actor: string): Promise<any[]>;
declare function getFIOAddresses(this: ApiClass, account: string): Promise<any>;
declare function getFIODomains(this: ApiClass, fio_public_key: string): Promise<any>;
declare function getFIOAddressesAndDomains(this: ApiClass, fio_public_key: string): Promise<unknown>;

declare function getAllMsigs(this: ApiClass): Promise<any>;
declare function getMsigProposal(this: ApiClass, accountName: string, proposalName: string): Promise<any>;
declare function parsePackedMsigActions(this: ApiClass, packedActions: any): Promise<{
    action_trace: {
        act: any;
    };
}[]>;
declare function parsePackedMsig(this: ApiClass, packed_transaction: any): Promise<any>;
declare function getFullMsigProposal(this: ApiClass, account_name: string, proposal_name: string): Promise<any>;
declare function getMsigApprovals(this: ApiClass, account: string, table: string): Promise<any[]>;
declare function getAccountsMsigProposals(this: ApiClass, account: string): Promise<any[]>;
declare function hyperionGetMsig(this: ApiClass, msigFilters: any): Promise<{
    approvals: _proton_hyperion_dist_src_types_state_get_proposals.Proposal;
    transaction: any;
    executionTransaction: {
        payer: any;
        trx_id: any;
        published_at: any;
        cancelled: boolean;
    } | undefined;
} | undefined>;

declare function getVoter(this: ApiClass, account: string): Promise<any>;
declare function getProxies(this: ApiClass): Promise<any>;
declare function getVoters(this: ApiClass, producer: string): Promise<any[] | undefined>;
declare function calculateVoteWeight(this: ApiClass): number;
declare function weightedVoteToNumber(this: ApiClass, weightedVote: number, voteWeight: number): number;
declare function getProxyData(this: ApiClass, accountName: string): Promise<any>;
declare function getProducersLocal(this: ApiClass): Promise<ProducerLocal[]>;
declare function getProducers(this: ApiClass, pageNum?: number, perPage?: number, local?: boolean): Promise<{
    count: number;
    producers: {
        country: string;
        flag: string;
        location: number;
        logo: string;
        nodes: {
            location: {
                name: string;
                country: string;
                latitude: number;
                longitude: number;
            }[];
        }[];
        num_votes: string;
        owner: string;
        percentage_votes: number;
        producer_authority: any;
        rank: number;
        rankChange: number;
        reward: string;
        telegram: string;
        twitter: string;
        candidate_name: string;
        url: string;
        voteNumChange: number;
        votePercentChange: number;
    }[];
} | ProducerLocal[]>;
declare function getChainTable(this: ApiClass): Promise<ChainGlobal>;

interface Authority {
    actor: string;
    permission: string;
}
interface PermissionLevel {
    permission: Authority;
    weight: number;
}
interface DelegatedBandwidth {
    from: string;
    to: string;
    cpu_weight: string;
    net_weight: string;
    cpu?: number;
    net?: number;
    total?: number;
}
interface ChainGlobal {
    max_block_net_usage: number;
    target_block_net_usage_pct: number;
    max_transaction_net_usage: number;
    base_per_transaction_net_usage: number;
    net_usage_leeway: number;
    context_free_discount_net_usage_num: number;
    context_free_discount_net_usage_den: number;
    max_block_cpu_usage: number;
    target_block_cpu_usage_pct: number;
    max_transaction_cpu_usage: number;
    min_transaction_cpu_usage: number;
    max_transaction_lifetime: number;
    deferred_trx_expiration_window: number;
    max_transaction_delay: number;
    max_inline_action_size: number;
    max_inline_action_depth: number;
    max_authority_depth: number;
    max_ram_size: number;
    total_ram_bytes_reserved: number;
    total_ram_stake: number;
    last_producer_schedule_update: string;
    last_pervote_bucket_fill: string;
    pervote_bucket: number;
    perblock_bucket: number;
    total_unpaid_blocks: number;
    total_activated_stake: number;
    thresh_activated_stake_time: string;
    last_producer_schedule_size: number;
    total_producer_vote_weight: number;
    last_name_close: string;
}
interface RexBal {
    version: number;
    owner: string;
    vote_stake: string;
    rex_balance: string;
    matured_rex: number;
    rex_maturities: {
        key?: string;
        value?: number;
        first?: string;
        second?: number;
    }[];
}
interface RexPoolRaw {
    version: number;
    total_lent: string;
    total_unlent: string;
    total_rent: string;
    total_lendable: string;
    total_rex: string;
    namebid_proceeds: string;
    loan_num: number;
}
interface RexPool {
    version: number;
    total_lent: number;
    total_unlent: number;
    total_rent: number;
    total_lendable: number;
    total_rex: number;
    namebid_proceeds: number;
    loan_num: number;
    lent_percent: BN;
    rex_price: number;
    resource_price: number;
}
interface RowsResponse<Row> {
    more: boolean;
    next_key: string;
    rows: Row[];
}
interface ProducerLocal {
    owner: string;
    total_votes: number;
    producer_key: string;
    is_active: boolean;
    url: string;
    unpaid_blocks: number;
    last_claim_time: string;
    location: number;
    producer_authority: any;
}

interface Country {
    id: string;
    name: string;
    region: string;
    active: boolean;
    localCurrency: string;
}
interface CountryOption {
    key: string;
    value: string;
    flag: string;
    text: string;
}
interface ApplyForKycParams {
    chain: string;
    actor: string;
    permission: string;
    transaction: any;
    signatures: string[];
    chainId: string;
}
interface KycApplyResponse {
    id: string;
    chainAccount: string;
    status: string;
    tier: number;
    created: Date;
    updated: Date;
}
interface KycIpInfo {
    ip: string;
    type: string;
    continent_code: string;
    continent_name: string;
    country_code: string;
    country_name: string;
    region_code: string;
    region_name: string;
    city: string;
    zip: string;
    latitude: number;
    longitude: number;
    location: {
        geoname_id: number;
        capital: string;
        languages: {
            code: string;
            name: string;
            native: string;
        }[];
        country_flag: string;
        country_flag_emoji: string;
        country_flag_emoji_unicode: string;
        calling_code: string;
        is_eu: boolean;
    };
    time_zone: {
        id: string;
        current_time: Date;
        gmt_offset: number;
        code: string;
        is_daylight_saving: boolean;
    };
    currency: {
        code: string;
        name: string;
        plural: string;
        symbol: string;
        symbol_native: string;
    };
    connection: {
        asn: number;
        isp: string;
    };
}
declare enum KycStatus {
    FAILED = "FAILED",
    UNSUBMITTED = "UNSUBMITTED",
    PENDING = "PENDING",
    PASSED = "PASSED"
}
declare type KycStatusResponse = {
    tier: string;
    status: KycStatus;
}[];
declare type FeatureResponse = "TRUE" | "FALSE" | "NEEDS_KYC";
interface AvailableFeatures {
    fiat: FeatureResponse;
    swap: FeatureResponse;
    loan: FeatureResponse;
    bridge: FeatureResponse;
}
interface CreateAccountParams {
    email: string;
    name: string;
    chainAccount: string;
    activePublicKey: string;
    ownerPublicKey: string;
    verificationCode?: string;
}
interface CreateOrLoginAccountResponse {
    id: string;
    token: string;
    refreshToken: string;
    expiresAt: number;
    createdAt: number;
    updatedAt: number;
    user: {
        id: string;
        email: string;
        emailVerified: boolean;
        chainAccount: string;
        status: string;
        createdAt: number;
        updatedAt: number;
    };
}
interface CreateOrLoginAccountResponseError {
    error: string;
    message: string;
}
interface LoginAccountParams {
    chainAccount: string;
    signature: string;
    email?: string;
    verificationCode?: string;
}
declare type IChainInfo = z.infer<typeof chainInfoParser>;
interface OraclePoint {
    d_string: string | null;
    d_uint64_t: string | number | null;
    d_double: string | null;
}
interface OracleRow {
    feed_index: number;
    aggregate: {
        d_string: string | null;
        d_uint64_t: string | number | null;
        d_double: string | null;
    };
    points: Array<{
        provider: string;
        time: string;
        data: OraclePoint;
    }>;
}

declare function fetchKycCountries(this: ApiClass, { chain }: {
    chain: string;
}): Promise<CountryOption[]>;
/**
 * FAILED
 * UNSUBMITTED
 * PENDING
 * PASSED
 */
declare function checkUserKycStatus(this: ApiClass, { chain, actor, expectedTier }: {
    chain: string;
    actor: string;
    expectedTier: number;
}): Promise<KycStatus>;
declare function applyForKyc(this: ApiClass, params: ApplyForKycParams): Promise<KycApplyResponse>;

declare function getChainInfo(this: ApiClass): Promise<IChainInfo | undefined>;
declare function getTokenPrices(this: ApiClass): Promise<ExchangeRates>;
declare function getWithdrawalFee(this: ApiClass, { currency, network }: {
    currency: string;
    network: string;
}): Promise<WithdrawalFeeQuote | undefined>;
declare function currentLocation(this: ApiClass): Promise<KycIpInfo>;
declare function getAvailableFeatures(this: ApiClass, account: string): Promise<AvailableFeatures>;
declare function createAccount(this: ApiClass, params: CreateAccountParams): Promise<CreateOrLoginAccountResponse>;
declare function loginAccount(this: ApiClass, params: LoginAccountParams): Promise<CreateOrLoginAccountResponse>;
declare function loginAccountV3(this: ApiClass, params: LoginAccountParamsV3): Promise<{
    token: string;
}>;

declare function otcQuote(this: ApiClass, body: OtcQuoteBody): Promise<{
    errormsg?: string | undefined;
    success: boolean;
    token: string;
    qty: number;
}>;
declare function otcOrder(this: ApiClass, id: string): Promise<OtcOrderResponse>;

declare const chainInfoParser: z.ZodObject<{
    chainId: z.ZodString;
    explorerUrl: z.ZodString;
    explorerName: z.ZodString;
    resourceTokenSymbol: z.ZodString;
    resourceTokenContract: z.ZodString;
    systemTokenSymbol: z.ZodString;
    systemTokenContract: z.ZodString;
    rpcEndpoints: z.ZodArray<z.ZodString, "many">;
    actionsRpcEndpoints: z.ZodArray<z.ZodString, "many">;
    hyperionEndpoints: z.ZodArray<z.ZodString, "many">;
    lightEndpoints: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    rpcEndpoints: string[];
    actionsRpcEndpoints: string[];
    chainId: string;
    explorerUrl: string;
    explorerName: string;
    resourceTokenSymbol: string;
    resourceTokenContract: string;
    systemTokenSymbol: string;
    systemTokenContract: string;
    hyperionEndpoints: string[];
    lightEndpoints: string[];
}, {
    rpcEndpoints: string[];
    actionsRpcEndpoints: string[];
    chainId: string;
    explorerUrl: string;
    explorerName: string;
    resourceTokenSymbol: string;
    resourceTokenContract: string;
    systemTokenSymbol: string;
    systemTokenContract: string;
    hyperionEndpoints: string[];
    lightEndpoints: string[];
}>;

declare function generateAddress(this: ApiClass, body: GenerateAddressBody): Promise<{
    memo?: string | undefined;
    address: string;
    coin: string;
    wallet: string;
    id: string;
}>;
declare function deleteAddress(this: ApiClass, body: GenerateAddressBody): Promise<boolean>;
declare function withdrawMetal(this: ApiClass, body: WithdrawBody): Promise<{
    success: boolean;
    id: string;
}>;
declare function withdrawalHistoryMetal(this: ApiClass, account: string): Promise<{
    swaps: {
        withdrawalHash?: string | undefined;
        id: string;
        status: string;
        amount: string;
        currency: string;
        network: string;
        created: string;
        withdrawalAddress: string;
    }[];
    page: number;
    pageSize: number;
    numberOfElements: number;
    totalPages: number;
    totalElements: number;
}>;

declare function getXprTotalStakedAndApr(this: ApiClass): Promise<0 | {
    supply: number;
    yieldFarming: number;
    producers: number;
    producersBlock: number;
    producersVote: number;
    consortium: number;
    staking: number;
    totalStaked: number;
    apr: number;
}>;
declare function getXprVoter(this: ApiClass, account: string): Promise<{
    owner: string;
    staked: number;
    isqualified: boolean;
    claimamount: number;
    lastclaim: number;
    startstake?: number;
    startqualif?: number;
} | undefined>;
declare function getXprAccountStakes(this: ApiClass, account: string): Promise<{
    from: string;
    to: string;
    quantity: string;
}[]>;
declare function getXprAccountRefund(this: ApiClass, account: string): Promise<{
    owner: string;
    request_time: string;
    quantity: number;
} | undefined>;
declare function getXprOracleData(this: ApiClass, oracleIndex: number): Promise<any>;
declare function getAllOracleFeeds(this: ApiClass, lower_bound?: any): Promise<any[]>;
declare function getSpecificOracleData(this: ApiClass, feed_index: number): Promise<OracleRow | undefined>;
declare function getAllOracleData(this: ApiClass, lower_bound?: any): Promise<OracleRow[]>;
declare function getProtonAvatars(this: ApiClass, account: string, limit?: number): Promise<RpcInterfaces.UserInfo[]>;
declare function getProtonAvatar(this: ApiClass, account: string): Promise<RpcInterfaces.UserInfo | undefined>;

declare function getRentbwState(this: ApiClass): Promise<any>;
declare function delegatedBandwidth(this: ApiClass, account: string, lower_bound: string): Promise<RowsResponse<DelegatedBandwidth>>;
declare function getAccountDelegatedBandwidth(this: ApiClass, account: string): Promise<DelegatedBandwidth[]>;
declare function getAccountResources(this: ApiClass, account: string): Promise<any>;
declare function getRamPriceInEos(this: ApiClass): Promise<number>;

declare function getEosTopStakes(this: ApiClass, limit?: number): Promise<_proton_light_api.GetTopStake>;
declare function getEosTopRams(this: ApiClass, limit?: number): Promise<_proton_light_api.GetTopRam>;
declare function getCurrentNameBids(this: ApiClass, lower_bound?: string, upper_bound?: string): Promise<any[]>;

declare function getRexQueued(this: ApiClass, account: string): Promise<any>;
declare function getRexPool(this: ApiClass): Promise<RexPool>;
declare function getRexBalance(this: ApiClass, account: string): Promise<RexBal | undefined>;
declare function getRexCpuLoans(this: ApiClass, account: string): Promise<any[]>;
declare function getRexNetLoans(this: ApiClass, account: string): Promise<any[]>;
declare function getEosDepositedIntoRex(this: ApiClass, account: string): Promise<number>;
declare function getRexReturnRate(this: ApiClass, type?: string): Promise<number>;
declare function getRexPriceChart(this: ApiClass): Promise<any>;

declare function getEosBalance(this: ApiClass, accountName: string): Promise<string>;
declare function getTokenBalance(this: ApiClass, contract: string, accountName: string, symbol: string): Promise<string | null>;
declare function getAccountTokens(this: ApiClass, accountName: string): Promise<{
    currency: string;
    amount: number;
    contract: string;
    decimals: number;
}[]>;
declare function lightGetTokens(this: ApiClass, account: string): Promise<{
    currency: string;
    amount: number;
    contract: string;
    decimals: number;
}[] | undefined>;
declare function hyperionGetTokensForAccount(this: ApiClass, account: string): Promise<{
    currency: string;
    amount: number;
    contract: string;
    decimals: number;
}[] | undefined>;
declare function getTokenSupply(this: ApiClass, contract: string, symbol: string): Promise<{
    supply: number;
    max_supply: number;
}>;

declare function getHistoryTransaction(this: ApiClass, txId: string, blockHint?: number): Promise<any>;
declare function getDeferredTransaction(this: ApiClass, txId: string): Promise<{}>;
declare function getHyperionTransaction(this: ApiClass, id: string): Promise<{
    status: string;
    cpu_usage: any;
    net_usage: number;
    id: any;
    block_time: any;
    block_num: any;
    delay_sec: string;
    expiration: string;
    lib: any;
    actions: any;
    traces: unknown[];
}>;
declare function generateTransactionSettings(this: ApiClass, expireSeconds?: number, blocksBehind?: number, delaySec?: number): Promise<{
    max_net_usage_words: number;
    max_cpu_usage_ms: number;
    delay_sec: number;
    context_free_actions: never[];
    actions: never[];
    transaction_extensions: never[];
}>;

declare function getControlledAccounts(this: ApiClass, accountName: string): never[] | Promise<any>;
declare function getPermissionLinks(this: ApiClass, account: string): Promise<any>;
declare function dfuseGetKeyAccounts(this: ApiClass, key: string): Promise<string[]>;
declare function nativeGetKeyAccounts(this: ApiClass, key: string): Promise<string[]>;
declare function hyperionGetKeyAccounts(this: ApiClass, key: string): Promise<string[]>;
declare function lightGetKeyAccounts(this: ApiClass, key: string): Promise<string[]>;
declare function getKeyAccountsByType(this: ApiClass, key: string, type: string): Promise<string[]>;
/**
 * Tries all histories to get keys.
 * @param {*} key
 */
declare function getKeyAccounts(this: ApiClass, key: string): Promise<string[]>;
declare function getKeyAccountsForAllChains(this: ApiClass, key: string): Promise<Array<{
    chain: string;
    accounts: string[];
}>>;
/**
 * Recursively resolves all required permissions
 * @param accountName
 * @param permission
 */
declare function getRequiredAccounts(this: ApiClass, accountName: string, permissionName: string, allPermissions?: any, currentLevel?: number, maxLevel?: number): Promise<any>;
declare function getUsersFromKeys(this: ApiClass, keys: string[]): Promise<any>;

declare class ApiClass {
    rpc: JsonRpc;
    actionsRpc: JsonRpc;
    api: Api;
    hyperion: Hyperion.JsonRpc;
    lightApi: _proton_light_api.JsonRpc;
    isInitialized: boolean;
    constants: typeof constants;
    constructor(chain?: string);
    initialize(constants: typeof constants, { rpcEndpoints, actionsRpcEndpoints, lightEndpoint, hyperionEndpoint }?: {
        rpcEndpoints?: string[];
        actionsRpcEndpoints?: string[];
        lightEndpoint?: string;
        hyperionEndpoint?: string;
    }): void;
    http: <T>({ path, method, body, headers }: {
        path: string;
        method: string;
        body?: any;
        headers?: any;
    }) => Promise<T>;
    get: <T>(path: string, headers?: any) => Promise<T>;
    post: <T>(path: string, body: any) => Promise<T>;
    getAccount: typeof getAccount;
    getGravatar: typeof getGravatar;
    searchAccount: typeof searchAccount;
    getParent: typeof getParent;
    getAccountLightData: typeof getAccountLightData;
    getActionsFromNative: typeof getActionsFromNative;
    getActions: typeof getActions;
    getActionsFromDfuse: typeof getActionsFromDfuse;
    getActionsFromHyperion: typeof getActionsFromHyperion;
    getDappStats: typeof getDappStats;
    getDspPackages: typeof getDspPackages;
    getDapphodlBalance: typeof getDapphodlBalance;
    getDappBalance: typeof getDappBalance;
    getDappStakes: typeof getDappStakes;
    getDapphodlStakes: typeof getDapphodlStakes;
    getDappUnstakes: typeof getDappUnstakes;
    getDapphodlUnstakes: typeof getDapphodlUnstakes;
    getFIOVoter: typeof getFIOVoter;
    getFIOPublicKey: typeof getFIOPublicKey;
    getFIOAddressByName: typeof getFIOAddressByName;
    getFIODomainByName: typeof getFIODomainByName;
    getNFTsByFioAddress: typeof getNFTsByFioAddress;
    getDomains: typeof getDomains;
    getAddresses: typeof getAddresses;
    getFIOProducers: typeof getFIOProducers;
    getFIOSupplyBreakdown: typeof getFIOSupplyBreakdown;
    getFIOFees: typeof getFIOFees;
    addFIOFeeToActions: typeof addFIOFeeToActions;
    getFIOAddresses: typeof getFIOAddresses;
    getFIODomains: typeof getFIODomains;
    getFIOAddressesAndDomains: typeof getFIOAddressesAndDomains;
    getFIOBalance: typeof getFIOBalance;
    getControlledAccounts: typeof getControlledAccounts;
    getPermissionLinks: typeof getPermissionLinks;
    dfuseGetKeyAccounts: typeof dfuseGetKeyAccounts;
    nativeGetKeyAccounts: typeof nativeGetKeyAccounts;
    hyperionGetKeyAccounts: typeof hyperionGetKeyAccounts;
    lightGetKeyAccounts: typeof lightGetKeyAccounts;
    getKeyAccountsByType: typeof getKeyAccountsByType;
    getKeyAccounts: typeof getKeyAccounts;
    getKeyAccountsForAllChains: typeof getKeyAccountsForAllChains;
    getRequiredAccounts: typeof getRequiredAccounts;
    getUsersFromKeys: typeof getUsersFromKeys;
    getAllMsigs: typeof getAllMsigs;
    parsePackedMsigActions: typeof parsePackedMsigActions;
    parsePackedMsig: typeof parsePackedMsig;
    getFullMsigProposal: typeof getFullMsigProposal;
    getMsigApprovals: typeof getMsigApprovals;
    getAccountsMsigProposals: typeof getAccountsMsigProposals;
    hyperionGetMsig: typeof hyperionGetMsig;
    getMsigProposal: typeof getMsigProposal;
    getRentbwState: typeof getRentbwState;
    delegatedBandwidth: typeof delegatedBandwidth;
    getAccountDelegatedBandwidth: typeof getAccountDelegatedBandwidth;
    getAccountResources: typeof getAccountResources;
    getRamPriceInEos: typeof getRamPriceInEos;
    getRexQueued: typeof getRexQueued;
    getRexPool: typeof getRexPool;
    getRexBalance: typeof getRexBalance;
    getRexCpuLoans: typeof getRexCpuLoans;
    getRexNetLoans: typeof getRexNetLoans;
    getEosDepositedIntoRex: typeof getEosDepositedIntoRex;
    getRexReturnRate: typeof getRexReturnRate;
    getRexPriceChart: typeof getRexPriceChart;
    getEosTopStakes: typeof getEosTopStakes;
    getEosTopRams: typeof getEosTopRams;
    getCurrentNameBids: typeof getCurrentNameBids;
    getEosBalance: typeof getEosBalance;
    getTokenBalance: typeof getTokenBalance;
    hyperionGetTokensForAccount: typeof hyperionGetTokensForAccount;
    getTokenSupply: typeof getTokenSupply;
    lightGetTokens: typeof lightGetTokens;
    getAccountTokens: typeof getAccountTokens;
    getHistoryTransaction: typeof getHistoryTransaction;
    getDeferredTransaction: typeof getDeferredTransaction;
    getHyperionTransaction: typeof getHyperionTransaction;
    generateTransactionSettings: typeof generateTransactionSettings;
    getProxies: typeof getProxies;
    getVoters: typeof getVoters;
    calculateVoteWeight: typeof calculateVoteWeight;
    weightedVoteToNumber: typeof weightedVoteToNumber;
    getProxyData: typeof getProxyData;
    getVoter: typeof getVoter;
    getProducers: typeof getProducers;
    getProducersLocal: typeof getProducersLocal;
    getChainTable: typeof getChainTable;
    fetchKycCountries: typeof fetchKycCountries;
    checkUserKycStatus: typeof checkUserKycStatus;
    applyForKyc: typeof applyForKyc;
    currentLocation: typeof currentLocation;
    getAvailableFeatures: typeof getAvailableFeatures;
    otcQuote: typeof otcQuote;
    otcOrder: typeof otcOrder;
    generateAddress: typeof generateAddress;
    deleteAddress: typeof deleteAddress;
    withdrawMetal: typeof withdrawMetal;
    withdrawalHistoryMetal: typeof withdrawalHistoryMetal;
    getTokenPrices: typeof getTokenPrices;
    getWithdrawalFee: typeof getWithdrawalFee;
    getChainInfo: typeof getChainInfo;
    createAccount: typeof createAccount;
    loginAccount: typeof loginAccount;
    loginAccountV3: typeof loginAccountV3;
    getXprTotalStakedAndApr: typeof getXprTotalStakedAndApr;
    getXprVoter: typeof getXprVoter;
    getXprAccountStakes: typeof getXprAccountStakes;
    getXprAccountRefund: typeof getXprAccountRefund;
    getXprOracleData: typeof getXprOracleData;
    getAllOracleFeeds: typeof getAllOracleFeeds;
    getAllOracleData: typeof getAllOracleData;
    getSpecificOracleData: typeof getSpecificOracleData;
    getProtonAvatar: typeof getProtonAvatar;
    getProtonAvatars: typeof getProtonAvatars;
}

export { ApiClass, ApplyForKycParams, Authority, AvailableFeatures, ChainGlobal, Country, CountryOption, CreateAccountParams, CreateOrLoginAccountResponse, CreateOrLoginAccountResponseError, DelegatedBandwidth, FeatureResponse, IChainInfo, KycApplyResponse, KycIpInfo, KycStatus, KycStatusResponse, LoginAccountParams, OraclePoint, OracleRow, PermissionLevel, ProducerLocal, RexBal, RexPool, RexPoolRaw, RowsResponse };
