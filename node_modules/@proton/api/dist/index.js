"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ApiClass: () => ApiClass,
  KycStatus: () => KycStatus
});
module.exports = __toCommonJS(src_exports);
var import_js5 = require("@proton/js");
var import_constants = require("@bloks/constants");
var Hyperion = __toESM(require("@proton/hyperion"));
var LightApi = __toESM(require("@proton/light-api"));

// src/account.ts
var import_js = require("@proton/js");
var import_utils = require("@bloks/utils");
async function getAccount(accountName) {
  try {
    const account = await this.rpc.get_account(accountName);
    account.permissions = account.permissions.map((permission) => {
      permission.required_auth.keys = permission.required_auth.keys.map((key) => {
        if (key.key.indexOf(this.constants.KEY_PREFIX) !== -1) {
          key.key = import_js.Numeric.convertLegacyPublicKey(key.key, this.constants.KEY_PREFIX);
        }
        return key;
      });
      return permission;
    });
    return account;
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function searchAccount(query, limit) {
  if (!query || !/(^[a-zA-Z12345.]+$)/.test(query)) {
    return [];
  }
  if (query.indexOf(".") === 0) {
    return [];
  }
  try {
    query = query.trim().toLowerCase();
    const { rows } = await this.rpc.get_table_by_scope({
      json: true,
      code: this.constants.EOSIO,
      limit,
      lower_bound: query,
      table: "userres",
      upper_bound: `${query}${query.length < 12 ? "z".repeat(12 - query.length) : ""}`
    });
    return rows.map((row) => row.scope);
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getGravatar(account) {
  if (this.constants.CHAIN === "eos") {
    const result = await this.rpc.get_table_rows({
      json: true,
      code: this.constants.ACCOUNT_INFO,
      scope: this.constants.ACCOUNT_INFO,
      table: "accounts",
      table_key: "",
      key_type: "name",
      lower_bound: account,
      index_position: 1,
      limit: 1
    });
    return result.rows.length > 0 && result.rows[0].account_name === account ? result.rows[0] : void 0;
  } else {
    return void 0;
  }
}
async function getParent(account) {
  if (this.constants.HISTORY_TYPES.includes("hyperion")) {
    if (this.constants.HYPERION_URL) {
      return this.hyperion.get_creator(account);
    } else {
      return this.get(
        (0, import_utils.urlBuilder)(this.constants.API_URL, "hyperion", {
          type: "get_creator",
          account
        })
      );
    }
  } else {
    return null;
  }
}
async function getAccountLightData(accountName) {
  if (!this.lightApi) {
    return void 0;
  }
  try {
    return await this.lightApi.get_account_info(accountName);
  } catch (e) {
    console.log(e);
    return void 0;
  }
}

// src/actions.ts
var import_utils2 = require("@bloks/utils");
async function getActionsFromNative(accountName, actionSkip, actionsPerPage, historyType = "native") {
  console.log("Fetching actions from:", historyType);
  console.log("Fetch Params:", "actionSkip", actionSkip, "actionsPerPage", actionsPerPage);
  const result = await this.actionsRpc.history_get_actions(accountName, actionSkip, actionsPerPage);
  if (!result) {
    throw new Error("Could not retrieve actions");
  }
  if (historyType === "native") {
    return (0, import_utils2.nativeTransformGetActions)(result, this.constants);
  }
  return [];
}
async function getActions(accountName, historyType, {
  actionsPerPage = 100,
  actionSkip = 0,
  sortDirection = "desc",
  dfuseCursorStack = [],
  tokenFilter,
  actionFilters,
  contractFilter,
  actionFilter,
  start,
  end
} = {}) {
  if (!start) {
    start = this.constants.CHAIN_START_DATE;
  }
  console.log(this.constants.HISTORY_TYPES);
  if (!historyType && this.constants.HISTORY_TYPES.length) {
    historyType = this.constants.HISTORY_TYPES[0];
  }
  if (start && end) {
    start = start || this.constants.CHAIN_START_DATE ? new Date(start || this.constants.CHAIN_START_DATE).toISOString() : void 0;
    end = new Date(end || new Date()).toISOString();
  } else {
    start = void 0;
    end = void 0;
  }
  let result;
  if (historyType === "dfuse") {
    const inputCursor = dfuseCursorStack.length > 0 ? dfuseCursorStack[dfuseCursorStack.length - 1] : "";
    result = await this.getActionsFromDfuse(accountName, {
      limit: actionsPerPage,
      cursor: inputCursor,
      direction: sortDirection,
      query: "",
      after: start,
      before: end,
      tokenFilter,
      actionFilters,
      contractFilter,
      actionFilter
    });
  } else if (historyType === "hyperion") {
    result = await this.getActionsFromHyperion(accountName, {
      skip: Math.abs(actionSkip) - 1,
      limit: actionsPerPage,
      sort: sortDirection,
      after: start,
      before: end,
      tokenFilter,
      actionFilters,
      contractFilter,
      actionFilter
    });
  } else {
    result = await this.getActionsFromNative(
      accountName,
      actionSkip,
      -actionsPerPage,
      "native"
    );
  }
  return result;
}
async function getActionsFromDfuse(accountName, {
  before,
  after,
  limit = 25,
  cursor,
  query,
  direction = "desc",
  tokenFilter,
  actionFilters,
  contractFilter,
  actionFilter,
  type = "search_transactions_graphql"
} = {}) {
  let q = query || `(auth:${accountName} OR
                    receiver:${accountName} OR
                    data.to:${accountName} OR
                    data.from:${accountName} OR
                    data.receiver:${accountName})`;
  if (tokenFilter) {
    let [, tokenContract] = tokenFilter.split(" ");
    let tokenfilter = `account:${tokenContract}`;
    q = `${q} ${tokenfilter}`;
  }
  if (actionFilters) {
    let actionFiltersLocal = Object.entries(actionFilters).reduce((filters, [, value]) => {
      return value.isActive ? filters.concat(value) : filters;
    }, []);
    if (actionFiltersLocal.length) {
      let actionFiltersQuery = actionFiltersLocal.map((filter) => filter.dfuseQuery(accountName)).join(" OR ");
      if (actionFiltersQuery.search("OR") !== -1) {
        actionFiltersQuery = `(${actionFiltersQuery})`;
      }
      q = `${q} ${actionFiltersQuery}`;
    }
    if (contractFilter) {
      q = `${q} account:${contractFilter}`;
    }
    if (actionFilter) {
      q = `${q} action:${actionFilter}`;
    }
  }
  let result = await this.get(
    (0, import_utils2.urlBuilder)(this.constants.API_URL, "dfuse", {
      type,
      q,
      options: Object.assign({}, {
        sort: direction,
        cursor,
        limit,
        withReversible: true,
        before,
        after,
        code: 1
      })
    })
  );
  if (!result) {
    throw new Error("Could not retrieve actions");
  }
  return (0, import_utils2.dfuseTransformGetActions)(result, accountName, this.constants);
}
async function getActionsFromHyperion(account, {
  skip,
  limit,
  sort,
  after,
  before,
  filter,
  tokenFilter,
  actionFilters,
  contractFilter,
  actionFilter
} = {}) {
  const params = {
    filter,
    skip,
    limit,
    sort,
    after,
    before
  };
  console.log("Fetching actions from Hyperion");
  let result;
  if (tokenFilter) {
    let [, tokenContract] = tokenFilter.split(" ");
    if (params.filter) {
      params.filter = params.filter.replace("*", tokenContract);
    } else {
      params.filter = `${tokenContract}:*`;
    }
  }
  if (actionFilters) {
    const actionFiltersLocal = Object.entries(actionFilters).reduce((filters, [, value]) => {
      return value.isActive ? filters.concat(value) : filters;
    }, []);
    if (actionFiltersLocal.length) {
      for (const eachFilter of actionFiltersLocal) {
        eachFilter.hyperionQuery(account, params);
      }
      console.log(params);
    }
  }
  if (contractFilter) {
    if (params.filter) {
      params.filter = params.filter.split(",").map((filter2) => `${contractFilter}:${filter2.split(":")[1]}`).join(",");
    } else {
      params.filter = `${contractFilter}:*`;
    }
  }
  if (actionFilter) {
    if (params.filter) {
      const uniqueContracts = Array.from(
        new Set(
          params.filter.split(",").map((filter2) => filter2.split(":")[0])
        )
      );
      params.filter = uniqueContracts.map((contract) => `${contract}:${actionFilter}`).join(",");
    } else {
      params.filter = `*:${actionFilter}`;
    }
  }
  if (this.constants.HYPERION_URL) {
    result = await this.hyperion.get_actions(account, Object.assign({}, params));
  } else {
    result = await this.get(
      (0, import_utils2.urlBuilder)(this.constants.API_URL, "hyperion", {
        type: "get_actions",
        account,
        options: Object.assign({}, params)
      })
    );
  }
  if (!result)
    throw new Error("Could not retrieve actions");
  return (0, import_utils2.hyperionTransformGetActions)(result);
}

// src/dsp.ts
async function getDappStats() {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappservices",
      json: true,
      limit: 1,
      scope: "......2ke1.o4",
      table: "statext"
    });
    if (!result || !result.rows || !result.rows.length) {
      return {};
    } else {
      return result.rows[0];
    }
  } catch (e) {
    console.log(e);
    return {};
  }
}
async function getDspPackages() {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappservices",
      json: true,
      limit: 500,
      scope: "dappservices",
      table: "package"
    });
    return result && result.rows && result.rows.length ? result.rows : [];
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getDapphodlBalance(account) {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappairhodl1",
      json: true,
      limit: 1,
      scope: account,
      table: "accounts"
    });
    return result && result.rows && result.rows.length ? result.rows[0] : {};
  } catch (e) {
    return {};
  }
}
async function getDappBalance(account) {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappservices",
      json: true,
      limit: 1,
      scope: account,
      table: "accounts"
    });
    return result && result.rows && result.rows.length ? result.rows[0] : {};
  } catch (e) {
    return {};
  }
}
async function getDappStakes(account) {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappservices",
      json: true,
      limit: 100,
      scope: account,
      table: "staking"
    });
    return result && result.rows && result.rows.length ? result.rows.map((row) => {
      row.scope = account;
      return row;
    }) : [];
  } catch (e) {
    return [];
  }
}
async function getDapphodlStakes(account, lower_bound = "") {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappservices",
      json: true,
      limit: 1e3,
      scope: "dappairhodl1",
      table: "staking",
      lower_bound
    });
    if (!result)
      return [];
    let rows = result.rows;
    if (result.more) {
      rows = rows.concat(await this.getDapphodlStakes(account, +rows[rows.length - 1].id + 1));
    }
    return rows.filter((row) => row.account === account).map((row) => {
      row.scope = "dappairhodl1";
      return row;
    });
  } catch (e) {
    return [];
  }
}
async function getDappUnstakes(account) {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappservices",
      json: true,
      limit: 100,
      scope: account,
      table: "refunds"
    });
    return result && result.rows && result.rows.length ? result.rows.map((row) => {
      row.scope = account;
      return row;
    }) : [];
  } catch (e) {
    return [];
  }
}
async function getDapphodlUnstakes(account) {
  try {
    const result = await this.rpc.get_table_rows({
      code: "dappservices",
      json: true,
      limit: 1e3,
      scope: "dappairhodl1",
      table: "refunds"
    });
    if (!result)
      return [];
    let rows = result.rows;
    if (result.more) {
      rows = rows.concat(await this.getDapphodlUnstakes(account));
    }
    return rows.filter((row) => row.account === account).map((row) => {
      row.scope = "dappairhodl1";
      return row;
    });
  } catch (e) {
    return [];
  }
}

// src/fio.ts
var import_utils3 = require("@bloks/utils");

// src/http.ts
var import_js2 = require("@proton/js");
var import_cross_fetch = __toESM(require("cross-fetch"));
var http = async ({
  path,
  method,
  body,
  headers
}) => {
  let data;
  let response;
  try {
    response = await (0, import_cross_fetch.default)(path, {
      method,
      body,
      headers: headers || {
        "Content-Type": "application/json"
      }
    });
    data = await response.json();
  } catch (e) {
    console.log(e);
  }
  if (!(response && response.ok)) {
    throw new import_js2.RpcError(data || "Error");
  }
  return data;
};
var get = async (path, headers) => {
  return await http({
    path,
    method: "GET",
    headers
  });
};
var post = async (path, body) => {
  return await http({
    path,
    method: "POST",
    body: JSON.stringify(body)
  });
};

// ../../node_modules/.pnpm/bignumber.js@9.1.0/node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, P.lt);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, P.gt);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply2(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply2(yc, n, base);
          xc = multiply2(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply2(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
          ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, method) {
    var n, i = 1, m = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      n = new BigNumber2(args[i]);
      if (!n.s) {
        m = n;
        break;
      } else if (method.call(m, n)) {
        m = n;
      }
    }
    return m;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
          ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = n / pows10[d - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
          }
        }
        r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy)
      t = xc, xc = yc, yc = t, y.s = -y.s;
    b = (j = yc.length) - (i = xc.length);
    if (b > 0)
      for (; b--; xc[i++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL)
      zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0)
      t = yc, yc = xc, xc = t, b = a;
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2)
        i = g1, g1 = g2, g2 = i, len -= i;
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z2, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z2 = LOG_BASE - s.length;
    for (; z2--; s = "0" + s)
      ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z2) {
  var len, zs;
  if (e < 0) {
    for (zs = z2 + "."; ++e; zs += z2)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z2, e -= len; --e; zs += z2)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();

// src/fio.ts
async function getFIOPublicKey(account) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      json: true,
      code: "fio.address",
      scope: "fio.address",
      lower_bound: (0, import_utils3.encodeName)(account, false),
      upper_bound: (0, import_utils3.encodeName)(account, false),
      table: "accountmap",
      limit: 1
    });
    return rows.length ? rows[0].clientkey : void 0;
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getFIOVoter(account) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      json: true,
      code: this.constants.EOSIO,
      scope: this.constants.EOSIO,
      lower_bound: (0, import_utils3.encodeName)(account, false),
      upper_bound: (0, import_utils3.encodeName)(account, false),
      table: "voters",
      key_type: "i64",
      index_position: 3,
      limit: 1
    });
    return rows.length ? rows[0] : void 0;
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getFIOAddressByName(name) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: "fio.address",
      scope: "fio.address",
      table: "fionames",
      lower_bound: "0x" + await (0, import_utils3.string_to_uint128_hash)(name),
      limit: 1,
      key_type: "i128",
      index_position: 5
    });
    if (rows && rows.length && rows[0].name === name) {
      return rows[0];
    } else {
      return void 0;
    }
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getNFTsByFioAddress(name) {
  try {
    const { nfts } = await this.rpc.get_nfts_fio_address(name);
    if (nfts && nfts.length) {
      return nfts;
    } else {
      return [];
    }
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getFIODomainByName(name) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: "fio.address",
      scope: "fio.address",
      table: "domains",
      lower_bound: "0x" + await (0, import_utils3.string_to_uint128_hash)(name),
      limit: 1,
      key_type: "i128",
      index_position: 4
    });
    if (rows && rows.length && rows[0].name === name) {
      return rows[0];
    } else {
      return void 0;
    }
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getDomains(limit = -1, upper_bound) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: "fio.address",
      scope: "fio.address",
      table: "domains",
      reverse: true,
      upper_bound,
      limit
    });
    if (rows && rows.length) {
      return rows;
    } else {
      return [];
    }
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getAddresses(limit = -1, upper_bound) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: "fio.address",
      scope: "fio.address",
      table: "fionames",
      reverse: true,
      upper_bound,
      limit
    });
    if (rows && rows.length) {
      return rows;
    } else {
      return [];
    }
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getFIOProducers(limit) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: this.constants.EOSIO,
      scope: this.constants.EOSIO,
      table: "producers",
      reverse: true,
      limit
    });
    if (rows && rows.length) {
      return rows;
    } else {
      return [];
    }
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getFIOBalance(fio_public_key) {
  try {
    const balance = await this.rpc.fetch("/v1/chain/get_fio_balance", {
      fio_public_key
    });
    if (balance) {
      return balance;
    } else {
      return null;
    }
  } catch (e) {
    console.log(e);
    return null;
  }
}
async function getFIOSupplyBreakdown() {
  const tokenRes = await this.rpc.get_table_rows({
    code: "fio.token",
    scope: "FIO",
    table: "stat"
  });
  const supply = +tokenRes.rows[0].supply.split(" ")[0];
  const bpRewardRes = await this.rpc.get_table_rows({
    code: "fio.treasury",
    scope: "fio.treasury",
    table: "bprewards"
  });
  const bpRewards = bpRewardRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
  const bpBucketRes = await this.rpc.get_table_rows({
    code: "fio.treasury",
    scope: "fio.treasury",
    table: "bpbucketpool"
  });
  const bpBucket = bpBucketRes.rows[0].rewards / Math.pow(10, this.constants.CORE_PRECISION);
  const totalBp = bpRewards + bpBucket;
  const circulating = await this.get("https://fioprotocol.io/circulating");
  const totalLocked = supply - +circulating;
  return {
    supply,
    totalLocked,
    bpRewards,
    bpBucket,
    totalBp,
    circulating
  };
}
async function getFIOFees() {
  return this.rpc.get_table_rows({
    code: "fio.fee",
    scope: "fio.fee",
    table: "fiofees",
    limit: -1
  }).then((result) => result.rows).catch((_) => []);
}
async function addFIOFeeToActions(actions, actor) {
  const fioFeesMap = {
    "eosio::deleteauth": "auth_delete",
    "eosio::linkauth": "auth_link",
    "eosio::regproducer": "register_producer",
    "eosio::regproxy": "register_proxy",
    "eosio::unregprod": "unregister_producer",
    "eosio::unregproxy": "unregister_proxy",
    "eosio::updateauth": "auth_update",
    "eosio::voteproducer": "vote_producer",
    "eosio::voteproxy": "proxy_vote",
    "fio.token::trnsfiopubky": "transfer_tokens_pub_key",
    "fio.address::addaddress": "add_pub_address",
    "fio.address::regaddress": "register_fio_address",
    "fio.address::regdomain": "register_fio_domain",
    "fio.address::renewaddress": "renew_fio_address",
    "fio.address::renewdomain": "renew_fio_domain",
    "fio.address::setdomainpub": "set_fio_domain_public",
    "eosio.msig::approve": "msig_approve",
    "eosio.msig::cancel": "msig_cancel",
    "eosio.msig::exec": "msig_exec",
    "eosio.msig::invalidate": "msig_invalidate",
    "eosio.msig::propose": "msig_propose",
    "eosio.msig::unapprove": "msig_approve",
    "fio.reqobt::newfundsreq": "new_funds_request",
    "fio.reqobt::rejectfndreq": "reject_funds_request",
    "fio.reqobt::cancelfndreq": "cancelfndreq",
    "fio.reqobt::recordobt": "record_obt_data",
    "fio.reqobt::newpubaddreq": "new_pub_address_request",
    "fio.reqobt::relpubadd": "release_pub_address",
    "fio.reqobt::rejectaddreq": "reject_pub_address_request",
    "fio.reqobt::canceladdreq": "cancel_pub_address_request",
    "fio.lock::trnsloctoks": "transfer_locked_tokens",
    "fio.lock::locktokens": "lock_tokens",
    "fio.address::remaddress": "remove_pub_address",
    "fio.address::remalladdr": "remove_all_pub_addresses",
    "fio.address::burnaddress": "burn_fio_address",
    "fio.address::xferdomain": "transfer_fio_domain",
    "fio.address::xferaddress": "transfer_fio_address"
  };
  const fees = await this.getFIOFees();
  let modifiedActions = [];
  for (let action of actions) {
    const { abi: { actions: abiActions, structs: abiStructs } } = await this.api.getCachedAbi(action.account);
    const relevantAction = abiActions.find((abiAction) => abiAction.name === action.name);
    if (relevantAction) {
      const relevantStruct = abiStructs.find((abiStruct) => abiStruct.name === relevantAction.type);
      if (relevantStruct) {
        const maxFeeField = relevantStruct.fields.find((field) => field.name === "max_fee");
        if (maxFeeField && action.data.max_fee === void 0) {
          const endpoint = fioFeesMap[`${action.account}::${action.name}`];
          if (endpoint) {
            const relevantFee = fees.find((fee) => fee.end_point === endpoint);
            if (relevantFee) {
              action.data.max_fee = relevantFee.suf_amount;
            } else {
              action.data.max_fee = 0;
            }
          }
        }
        const actorField = relevantStruct.fields.find((field) => field.name === "actor");
        if (actorField && action.data.actor === void 0) {
          action.data.actor = actor;
        }
        const tpidField = relevantStruct.fields.find((field) => field.name === "tpid");
        if (tpidField && action.data.tpid === void 0) {
          action.data.tpid = this.constants.FIO_FEES_ACCOUNT;
        }
        const addressField = relevantStruct.fields.find((field) => field.name === "fio_address");
        if (addressField && action.data.fio_address === void 0) {
          const addresses = await this.getFIOAddresses(actor);
          if (addresses.length) {
            action.data.fio_address = addresses[0].name;
          }
        }
      }
    }
    modifiedActions.push(action);
  }
  return modifiedActions;
}
function getFIOAddresses(account) {
  return this.rpc.get_table_rows({
    code: "fio.address",
    scope: "fio.address",
    table: "fionames",
    key_type: "i64",
    limit: -1,
    lower_bound: (0, import_utils3.encodeName)(account, false),
    upper_bound: new BigNumber((0, import_utils3.encodeName)(account, false)).plus(1).toString(),
    index_position: 4
  }).then((result) => {
    if (result.rows.length > 0) {
      return result.rows.filter((row) => row.owner_account === account);
    } else {
      return [];
    }
  }).catch((_) => []);
}
async function getFIODomains(fio_public_key) {
  try {
    const { fio_domains } = await this.rpc.fetch("/v1/chain/get_fio_domains", {
      fio_public_key
    });
    for (const domain of fio_domains) {
      domain.name = domain.fio_domain;
    }
    return fio_domains;
  } catch (e) {
    console.log(e);
    return [];
  }
}
function getFIOAddressesAndDomains(fio_public_key) {
  return post(`${this.constants.DEFAULT_ENDPOINTS[0]}/v1/get_fio_names`, { fio_public_key });
}

// src/msig.ts
var import_utils4 = require("@bloks/utils");
async function getAllMsigs() {
  if (this.constants.HISTORY_TYPES.includes("dfuse")) {
    let { tables } = await this.get(
      (0, import_utils4.urlBuilder)(this.constants.API_URL, "dfuse", {
        type: "state_scope_pipeline",
        account: this.constants.EOSIO_MSIG,
        table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
        options: {}
      })
    );
    tables = tables.map((table) => {
      table.rows = table.rows.sort((a, b) => b.block - a.block);
      table.highestBlock = table.rows[0].block;
      return table;
    }).sort((a, b) => b.highestBlock - a.highestBlock);
    return tables;
  } else {
    let rows = [];
    let lower_bound = "";
    do {
      const result = await this.rpc.get_table_by_scope({
        json: true,
        code: "eosio.msig",
        limit: 100,
        lower_bound,
        table: "proposal",
        upper_bound: ""
      });
      lower_bound = result.more;
      rows = rows.concat(result.rows);
    } while (lower_bound);
    return rows.map(
      (row) => ({
        scope: row.scope,
        rows: Array(row.count).fill({ key: "" })
      })
    );
  }
}
async function getMsigProposal(accountName, proposalName) {
  const { rows } = await this.rpc.get_table_rows({
    json: true,
    code: "eosio.msig",
    scope: accountName,
    limit: 1,
    lower_bound: proposalName,
    table: "proposal"
  });
  if (rows && rows.length && rows[0].proposal_name === proposalName) {
    return rows[0];
  } else {
    return void 0;
  }
}
async function parsePackedMsigActions(packedActions) {
  let actions = [];
  for (let action of packedActions) {
    if (action.account === this.constants.EOSIO_MSIG && action.name === "propose") {
      action.data.trx.actions = await this.api.deserializeActionsSync(action.data.trx.actions);
    }
    if (action.account === this.constants.EOSIO && action.name === "setabi") {
      action.data.abi = await this.api.rawAbiToJson((0, import_utils4.hexToUint8Array)(action.data.abi));
    }
    actions.push(action);
  }
  actions = actions.map((action) => ({
    action_trace: {
      act: action
    }
  }));
  return actions;
}
async function parsePackedMsig(packed_transaction) {
  try {
    const tx = await this.api.deserializeTransactionWithActions(packed_transaction);
    tx.actions = await this.parsePackedMsigActions(tx.actions);
    return tx;
  } catch (e) {
    console.log("Error parsing packed msig");
    console.log(e);
  }
}
async function getFullMsigProposal(account_name, proposal_name) {
  try {
    const result = await this.rpc.get_table_rows({
      json: true,
      code: this.constants.EOSIO_MSIG,
      scope: (0, import_utils4.encodeName)(account_name, false),
      table: this.constants.EOSIO_MSIG_PROPOSALS_TABLE,
      table_key: "",
      key_type: "name",
      lower_bound: proposal_name,
      index_position: 1,
      limit: 1
    });
    if (result && result.rows && result.rows.length) {
      return await this.parsePackedMsig(result.rows[0].packed_transaction);
    }
  } catch (e) {
    console.log(e);
  }
}
async function getMsigApprovals(account, table) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      json: true,
      code: this.constants.EOSIO_MSIG,
      scope: (0, import_utils4.encodeName)(account, false),
      table,
      limit: -1
    });
    return rows;
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getAccountsMsigProposals(account) {
  try {
    const promises = [this.getMsigApprovals(account, this.constants.EOSIO_MSIG_APPROVALS_TABLE)];
    if (this.constants.EOSIO_MSIG_APPROVALS_TABLE === "approvals2") {
      promises.push(this.getMsigApprovals(account, "approvals"));
    }
    const [rows2, rows1] = await Promise.all(promises);
    return rows2.concat(rows1);
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function hyperionGetMsig(msigFilters) {
  if (!this.hyperion)
    return void 0;
  const res = await this.hyperion.get_proposals(msigFilters);
  if (res && res.proposals && res.proposals.length) {
    let executionTransaction, transaction;
    const proposal = res.proposals[0];
    const [actionsRes, actionsRes2] = await Promise.all([
      this.hyperion.get_actions(this.constants.EOSIO_MSIG, {
        block_num: proposal.block_num,
        limit: 1
      }),
      this.hyperion.get_deltas(this.constants.EOSIO_MSIG, msigFilters.proposer, "proposal", void 0, { block_num: proposal.block_num })
    ]);
    if (actionsRes && actionsRes.actions && actionsRes.actions.length) {
      const relevantAction = actionsRes.actions.find((action) => action.act.data.proposal_name === msigFilters.proposal);
      if (relevantAction) {
        executionTransaction = {
          payer: relevantAction.act.data.executer || relevantAction.act.data.canceler,
          trx_id: relevantAction.trx_id,
          published_at: relevantAction.timestamp,
          cancelled: relevantAction.act.name === "cancel"
        };
      }
    }
    if (actionsRes2 && actionsRes2.deltas && actionsRes2.deltas.length) {
      const tx = actionsRes2.deltas[0].data.transaction;
      tx.actions = await this.parsePackedMsigActions(tx.actions);
      transaction = tx;
    }
    return {
      approvals: proposal,
      transaction,
      executionTransaction
    };
  } else {
    return void 0;
  }
}

// src/voting.ts
var import_utils5 = require("@bloks/utils");
async function getVoter(account) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      json: true,
      code: this.constants.EOSIO,
      scope: this.constants.EOSIO,
      lower_bound: (0, import_utils5.encodeName)(account, false),
      upper_bound: (0, import_utils5.encodeName)(account, false),
      table: "voters",
      limit: 1
    });
    return rows.length ? rows[0] : void 0;
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getProxies() {
  if (this.constants.ALOHA_PROXY_URL !== "") {
    const { proxies } = await this.get(`${this.constants.ALOHA_PROXY_URL}?output=json`);
    return proxies;
  } else {
    const { voters } = await this.hyperion.get_voters({ proxy: true, limit: 1e3 });
    return voters.map((voter, index) => ({
      ...voter,
      weight: voter.weight / Math.pow(10, this.constants.CORE_PRECISION),
      rank: index + 1
    }));
  }
}
async function getVoters(producer) {
  if (this.hyperion) {
    const { voters } = await this.hyperion.get_voters({
      producer,
      limit: 100
    });
    const voteWeight = this.calculateVoteWeight();
    return voters.map((voter) => ({
      ...voter,
      vote: this.weightedVoteToNumber(voter.weight, voteWeight)
    }));
  } else {
    return void 0;
  }
}
function calculateVoteWeight() {
  let decayWeeks = this.constants.CHAIN === "wax" ? 13 : 52;
  let timestamp_epoch = 9466848e5;
  let dates = Date.now() / 1e3 - timestamp_epoch / 1e3;
  let weight = Math.floor(dates / (86400 * 7)) / decayWeeks;
  return Math.pow(2, weight);
}
function weightedVoteToNumber(weightedVote, voteWeight) {
  if (!voteWeight) {
    voteWeight = this.calculateVoteWeight();
  }
  return +weightedVote / voteWeight / Math.pow(10, this.constants.CORE_PRECISION);
}
async function getProxyData(accountName) {
  if (this.constants.ALOHA_PROXY_URL !== "") {
    const { proxy } = await this.get(`${this.constants.ALOHA_PROXY_URL}/${accountName}?output=json`);
    return proxy;
  } else {
    return void 0;
  }
}
async function getProducersLocal() {
  let more = true;
  let rows = [];
  let result = null;
  let lower_bound = null;
  do {
    result = await this.rpc.get_table_rows({
      json: true,
      code: this.constants.EOSIO,
      scope: this.constants.EOSIO,
      table: "producers",
      lower_bound,
      index_position: 1,
      key_type: "i64",
      limit: 100
    });
    more = result.more;
    rows = rows.concat(result.rows);
    lower_bound = new BigNumber(
      (0, import_utils5.encodeName)(rows[rows.length - 1].owner, false)
    ).plus(1).toString();
  } while (more);
  return rows;
}
async function getProducers(pageNum = 1, perPage = 50, local = false) {
  if (this.constants.API_URL !== "" && !local) {
    return await this.get(
      (0, import_utils5.urlBuilder)(this.constants.API_URL, "producers", {
        pageNum,
        perPage
      })
    );
  } else {
    return this.getProducersLocal();
  }
}
async function getChainTable() {
  const { rows } = await this.rpc.get_table_rows({
    code: this.constants.EOSIO,
    scope: this.constants.EOSIO,
    table: "global",
    limit: 1
  });
  return rows[0];
}

// src/types/proton.ts
var KycStatus = /* @__PURE__ */ ((KycStatus2) => {
  KycStatus2["FAILED"] = "FAILED";
  KycStatus2["UNSUBMITTED"] = "UNSUBMITTED";
  KycStatus2["PENDING"] = "PENDING";
  KycStatus2["PASSED"] = "PASSED";
  return KycStatus2;
})(KycStatus || {});

// src/proton/countryOptions.ts
var countryOptions_default = [
  { key: "AF", value: "AF", flag: "af", text: "Afghanistan" },
  { key: "AX", value: "AX", flag: "ax", text: "Aland Islands" },
  { key: "AL", value: "AL", flag: "al", text: "Albania" },
  { key: "DZ", value: "DZ", flag: "dz", text: "Algeria" },
  { key: "AS", value: "AS", flag: "as", text: "American Samoa" },
  { key: "AD", value: "AD", flag: "ad", text: "Andorra" },
  { key: "AO", value: "AO", flag: "ao", text: "Angola" },
  { key: "AI", value: "AI", flag: "ai", text: "Anguilla" },
  { key: "AG", value: "AG", flag: "ag", text: "Antigua" },
  { key: "AR", value: "AR", flag: "ar", text: "Argentina" },
  { key: "AM", value: "AM", flag: "am", text: "Armenia" },
  { key: "AW", value: "AW", flag: "aw", text: "Aruba" },
  { key: "AU", value: "AU", flag: "au", text: "Australia" },
  { key: "AT", value: "AT", flag: "at", text: "Austria" },
  { key: "AZ", value: "AZ", flag: "az", text: "Azerbaijan" },
  { key: "BS", value: "BS", flag: "bs", text: "Bahamas" },
  { key: "BH", value: "BH", flag: "bh", text: "Bahrain" },
  { key: "BD", value: "BD", flag: "bd", text: "Bangladesh" },
  { key: "BB", value: "BB", flag: "bb", text: "Barbados" },
  { key: "BY", value: "BY", flag: "by", text: "Belarus" },
  { key: "BE", value: "BE", flag: "be", text: "Belgium" },
  { key: "BZ", value: "BZ", flag: "bz", text: "Belize" },
  { key: "BJ", value: "BJ", flag: "bj", text: "Benin" },
  { key: "BM", value: "BM", flag: "bm", text: "Bermuda" },
  { key: "BT", value: "BT", flag: "bt", text: "Bhutan" },
  { key: "BO", value: "BO", flag: "bo", text: "Bolivia" },
  { key: "BA", value: "BA", flag: "ba", text: "Bosnia" },
  { key: "BW", value: "BW", flag: "bw", text: "Botswana" },
  { key: "BV", value: "BV", flag: "bv", text: "Bouvet Island" },
  { key: "BR", value: "BR", flag: "br", text: "Brazil" },
  { key: "VG", value: "VG", flag: "vg", text: "British Virgin Islands" },
  { key: "BN", value: "BN", flag: "bn", text: "Brunei" },
  { key: "BG", value: "BG", flag: "bg", text: "Bulgaria" },
  { key: "BF", value: "BF", flag: "bf", text: "Burkina Faso" },
  { key: "BI", value: "BI", flag: "bi", text: "Burundi" },
  { key: "TC", value: "TC", flag: "tc", text: "Caicos Islands" },
  { key: "KH", value: "KH", flag: "kh", text: "Cambodia" },
  { key: "CM", value: "CM", flag: "cm", text: "Cameroon" },
  { key: "CA", value: "CA", flag: "ca", text: "Canada" },
  { key: "CV", value: "CV", flag: "cv", text: "Cape Verde" },
  { key: "KY", value: "KY", flag: "ky", text: "Cayman Islands" },
  { key: "CF", value: "CF", flag: "cf", text: "Central African Republic" },
  { key: "TD", value: "TD", flag: "td", text: "Chad" },
  { key: "CL", value: "CL", flag: "cl", text: "Chile" },
  { key: "CN", value: "CN", flag: "cn", text: "China" },
  { key: "CX", value: "CX", flag: "cx", text: "Christmas Island" },
  { key: "CC", value: "CC", flag: "cc", text: "Cocos Islands" },
  { key: "CO", value: "CO", flag: "co", text: "Colombia" },
  { key: "KM", value: "KM", flag: "km", text: "Comoros" },
  { key: "CG", value: "CG", flag: "cg", text: "Congo Brazzaville" },
  { key: "CD", value: "CD", flag: "cd", text: "Congo" },
  { key: "CK", value: "CK", flag: "ck", text: "Cook Islands" },
  { key: "CR", value: "CR", flag: "cr", text: "Costa Rica" },
  { key: "CI", value: "CI", flag: "ci", text: "Cote Divoire" },
  { key: "HR", value: "HR", flag: "hr", text: "Croatia" },
  { key: "CU", value: "CU", flag: "cu", text: "Cuba" },
  { key: "CY", value: "CY", flag: "cy", text: "Cyprus" },
  { key: "CZ", value: "CZ", flag: "cz", text: "Czech Republic" },
  { key: "DK", value: "DK", flag: "dk", text: "Denmark" },
  { key: "DJ", value: "DJ", flag: "dj", text: "Djibouti" },
  { key: "DM", value: "DM", flag: "dm", text: "Dominica" },
  { key: "DO", value: "DO", flag: "do", text: "Dominican Republic" },
  { key: "EC", value: "EC", flag: "ec", text: "Ecuador" },
  { key: "EG", value: "EG", flag: "eg", text: "Egypt" },
  { key: "SV", value: "SV", flag: "sv", text: "El Salvador" },
  { key: "GB", value: "GB", flag: "gb", text: "England" },
  { key: "GQ", value: "GQ", flag: "gq", text: "Equatorial Guinea" },
  { key: "ER", value: "ER", flag: "er", text: "Eritrea" },
  { key: "EE", value: "EE", flag: "ee", text: "Estonia" },
  { key: "ET", value: "ET", flag: "et", text: "Ethiopia" },
  { key: "EU", value: "EU", flag: "eu", text: "European Union" },
  { key: "FK", value: "FK", flag: "fk", text: "Falkland Islands" },
  { key: "FO", value: "FO", flag: "fo", text: "Faroe Islands" },
  { key: "FJ", value: "FJ", flag: "fj", text: "Fiji" },
  { key: "FI", value: "FI", flag: "fi", text: "Finland" },
  { key: "FR", value: "FR", flag: "fr", text: "France" },
  { key: "GF", value: "GF", flag: "gf", text: "French Guiana" },
  { key: "PF", value: "PF", flag: "pf", text: "French Polynesia" },
  { key: "TF", value: "TF", flag: "tf", text: "French Territories" },
  { key: "GA", value: "GA", flag: "ga", text: "Gabon" },
  { key: "GM", value: "GM", flag: "gm", text: "Gambia" },
  { key: "GE", value: "GE", flag: "ge", text: "Georgia" },
  { key: "DE", value: "DE", flag: "de", text: "Germany" },
  { key: "GH", value: "GH", flag: "gh", text: "Ghana" },
  { key: "GI", value: "GI", flag: "gi", text: "Gibraltar" },
  { key: "GR", value: "GR", flag: "gr", text: "Greece" },
  { key: "GL", value: "GL", flag: "gl", text: "Greenland" },
  { key: "GD", value: "GD", flag: "gd", text: "Grenada" },
  { key: "GP", value: "GP", flag: "gp", text: "Guadeloupe" },
  { key: "GU", value: "GU", flag: "gu", text: "Guam" },
  { key: "GT", value: "GT", flag: "gt", text: "Guatemala" },
  { key: "GW", value: "GW", flag: "gw", text: "Guinea-Bissau" },
  { key: "GN", value: "GN", flag: "gn", text: "Guinea" },
  { key: "GY", value: "GY", flag: "gy", text: "Guyana" },
  { key: "HT", value: "HT", flag: "ht", text: "Haiti" },
  { key: "HM", value: "HM", flag: "hm", text: "Heard Island" },
  { key: "HN", value: "HN", flag: "hn", text: "Honduras" },
  { key: "HK", value: "HK", flag: "hk", text: "Hong Kong" },
  { key: "HU", value: "HU", flag: "hu", text: "Hungary" },
  { key: "IS", value: "IS", flag: "is", text: "Iceland" },
  { key: "IN", value: "IN", flag: "in", text: "India" },
  { key: "IO", value: "IO", flag: "io", text: "Indian Ocean Territory" },
  { key: "ID", value: "ID", flag: "id", text: "Indonesia" },
  { key: "IR", value: "IR", flag: "ir", text: "Iran" },
  { key: "IQ", value: "IQ", flag: "iq", text: "Iraq" },
  { key: "IE", value: "IE", flag: "ie", text: "Ireland" },
  { key: "IL", value: "IL", flag: "il", text: "Israel" },
  { key: "IT", value: "IT", flag: "it", text: "Italy" },
  { key: "JM", value: "JM", flag: "jm", text: "Jamaica" },
  { key: "JP", value: "JP", flag: "jp", text: "Japan" },
  { key: "JO", value: "JO", flag: "jo", text: "Jordan" },
  { key: "KZ", value: "KZ", flag: "kz", text: "Kazakhstan" },
  { key: "KE", value: "KE", flag: "ke", text: "Kenya" },
  { key: "KI", value: "KI", flag: "ki", text: "Kiribati" },
  { key: "KW", value: "KW", flag: "kw", text: "Kuwait" },
  { key: "KG", value: "KG", flag: "kg", text: "Kyrgyzstan" },
  { key: "LA", value: "LA", flag: "la", text: "Laos" },
  { key: "LV", value: "LV", flag: "lv", text: "Latvia" },
  { key: "LB", value: "LB", flag: "lb", text: "Lebanon" },
  { key: "LS", value: "LS", flag: "ls", text: "Lesotho" },
  { key: "LR", value: "LR", flag: "lr", text: "Liberia" },
  { key: "LY", value: "LY", flag: "ly", text: "Libya" },
  { key: "LI", value: "LI", flag: "li", text: "Liechtenstein" },
  { key: "LT", value: "LT", flag: "lt", text: "Lithuania" },
  { key: "LU", value: "LU", flag: "lu", text: "Luxembourg" },
  { key: "MO", value: "MO", flag: "mo", text: "Macau" },
  { key: "MK", value: "MK", flag: "mk", text: "Macedonia" },
  { key: "MG", value: "MG", flag: "mg", text: "Madagascar" },
  { key: "MW", value: "MW", flag: "mw", text: "Malawi" },
  { key: "MY", value: "MY", flag: "my", text: "Malaysia" },
  { key: "MV", value: "MV", flag: "mv", text: "Maldives" },
  { key: "ML", value: "ML", flag: "ml", text: "Mali" },
  { key: "MT", value: "MT", flag: "mt", text: "Malta" },
  { key: "MH", value: "MH", flag: "mh", text: "Marshall Islands" },
  { key: "MQ", value: "MQ", flag: "mq", text: "Martinique" },
  { key: "MR", value: "MR", flag: "mr", text: "Mauritania" },
  { key: "MU", value: "MU", flag: "mu", text: "Mauritius" },
  { key: "YT", value: "YT", flag: "yt", text: "Mayotte" },
  { key: "MX", value: "MX", flag: "mx", text: "Mexico" },
  { key: "FM", value: "FM", flag: "fm", text: "Micronesia" },
  { key: "MD", value: "MD", flag: "md", text: "Moldova" },
  { key: "MC", value: "MC", flag: "mc", text: "Monaco" },
  { key: "MN", value: "MN", flag: "mn", text: "Mongolia" },
  { key: "ME", value: "ME", flag: "me", text: "Montenegro" },
  { key: "MS", value: "MS", flag: "ms", text: "Montserrat" },
  { key: "MA", value: "MA", flag: "ma", text: "Morocco" },
  { key: "MZ", value: "MZ", flag: "mz", text: "Mozambique" },
  { key: "NA", value: "NA", flag: "na", text: "Namibia" },
  { key: "NR", value: "NR", flag: "nr", text: "Nauru" },
  { key: "NP", value: "NP", flag: "np", text: "Nepal" },
  { key: "AN", value: "AN", flag: "an", text: "Netherlands Antilles" },
  { key: "NL", value: "NL", flag: "nl", text: "Netherlands" },
  { key: "NC", value: "NC", flag: "nc", text: "New Caledonia" },
  { key: "PG", value: "PG", flag: "pg", text: "New Guinea" },
  { key: "NZ", value: "NZ", flag: "nz", text: "New Zealand" },
  { key: "NI", value: "NI", flag: "ni", text: "Nicaragua" },
  { key: "NE", value: "NE", flag: "ne", text: "Niger" },
  { key: "NG", value: "NG", flag: "ng", text: "Nigeria" },
  { key: "NU", value: "NU", flag: "nu", text: "Niue" },
  { key: "NF", value: "NF", flag: "nf", text: "Norfolk Island" },
  { key: "KP", value: "KP", flag: "kp", text: "North Korea" },
  { key: "MP", value: "MP", flag: "mp", text: "Northern Mariana Islands" },
  { key: "NO", value: "NO", flag: "no", text: "Norway" },
  { key: "OM", value: "OM", flag: "om", text: "Oman" },
  { key: "PK", value: "PK", flag: "pk", text: "Pakistan" },
  { key: "PW", value: "PW", flag: "pw", text: "Palau" },
  { key: "PS", value: "PS", flag: "ps", text: "Palestine" },
  { key: "PA", value: "PA", flag: "pa", text: "Panama" },
  { key: "PY", value: "PY", flag: "py", text: "Paraguay" },
  { key: "PE", value: "PE", flag: "pe", text: "Peru" },
  { key: "PH", value: "PH", flag: "ph", text: "Philippines" },
  { key: "PN", value: "PN", flag: "pn", text: "Pitcairn Islands" },
  { key: "PL", value: "PL", flag: "pl", text: "Poland" },
  { key: "PT", value: "PT", flag: "pt", text: "Portugal" },
  { key: "PR", value: "PR", flag: "pr", text: "Puerto Rico" },
  { key: "QA", value: "QA", flag: "qa", text: "Qatar" },
  { key: "RE", value: "RE", flag: "re", text: "Reunion" },
  { key: "RO", value: "RO", flag: "ro", text: "Romania" },
  { key: "RU", value: "RU", flag: "ru", text: "Russia" },
  { key: "RW", value: "RW", flag: "rw", text: "Rwanda" },
  { key: "SH", value: "SH", flag: "sh", text: "Saint Helena" },
  { key: "KN", value: "KN", flag: "kn", text: "Saint Kitts and Nevis" },
  { key: "LC", value: "LC", flag: "lc", text: "Saint Lucia" },
  { key: "PM", value: "PM", flag: "pm", text: "Saint Pierre" },
  { key: "VC", value: "VC", flag: "vc", text: "Saint Vincent" },
  { key: "WS", value: "WS", flag: "ws", text: "Samoa" },
  { key: "SM", value: "SM", flag: "sm", text: "San Marino" },
  { key: "GS", value: "GS", flag: "gs", text: "Sandwich Islands" },
  { key: "ST", value: "ST", flag: "st", text: "Sao Tome" },
  { key: "SA", value: "SA", flag: "sa", text: "Saudi Arabia" },
  { key: "SN", value: "SN", flag: "sn", text: "Senegal" },
  { key: "CS", value: "CS", flag: "cs", text: "Serbia" },
  { key: "RS", value: "RS", flag: "rs", text: "Serbia" },
  { key: "SC", value: "SC", flag: "sc", text: "Seychelles" },
  { key: "SL", value: "SL", flag: "sl", text: "Sierra Leone" },
  { key: "SG", value: "SG", flag: "sg", text: "Singapore" },
  { key: "SK", value: "SK", flag: "sk", text: "Slovakia" },
  { key: "SI", value: "SI", flag: "si", text: "Slovenia" },
  { key: "SB", value: "SB", flag: "sb", text: "Solomon Islands" },
  { key: "SO", value: "SO", flag: "so", text: "Somalia" },
  { key: "ZA", value: "ZA", flag: "za", text: "South Africa" },
  { key: "KR", value: "KR", flag: "kr", text: "South Korea" },
  { key: "ES", value: "ES", flag: "es", text: "Spain" },
  { key: "LK", value: "LK", flag: "lk", text: "Sri Lanka" },
  { key: "SD", value: "SD", flag: "sd", text: "Sudan" },
  { key: "SR", value: "SR", flag: "sr", text: "Suriname" },
  { key: "SJ", value: "SJ", flag: "sj", text: "Svalbard" },
  { key: "SZ", value: "SZ", flag: "sz", text: "Swaziland" },
  { key: "SE", value: "SE", flag: "se", text: "Sweden" },
  { key: "CH", value: "CH", flag: "ch", text: "Switzerland" },
  { key: "SY", value: "SY", flag: "sy", text: "Syria" },
  { key: "TW", value: "TW", flag: "tw", text: "Taiwan" },
  { key: "TJ", value: "TJ", flag: "tj", text: "Tajikistan" },
  { key: "TZ", value: "TZ", flag: "tz", text: "Tanzania" },
  { key: "TH", value: "TH", flag: "th", text: "Thailand" },
  { key: "TL", value: "TL", flag: "tl", text: "Timorleste" },
  { key: "TG", value: "TG", flag: "tg", text: "Togo" },
  { key: "TK", value: "TK", flag: "tk", text: "Tokelau" },
  { key: "TO", value: "TO", flag: "to", text: "Tonga" },
  { key: "TT", value: "TT", flag: "tt", text: "Trinidad" },
  { key: "TN", value: "TN", flag: "tn", text: "Tunisia" },
  { key: "TR", value: "TR", flag: "tr", text: "Turkey" },
  { key: "TM", value: "TM", flag: "tm", text: "Turkmenistan" },
  { key: "TV", value: "TV", flag: "tv", text: "Tuvalu" },
  { key: "UG", value: "UG", flag: "ug", text: "Uganda" },
  { key: "UA", value: "UA", flag: "ua", text: "Ukraine" },
  { key: "AE", value: "AE", flag: "ae", text: "United Arab Emirates" },
  { key: "US", value: "US", flag: "us", text: "United States" },
  { key: "UY", value: "UY", flag: "uy", text: "Uruguay" },
  { key: "UM", value: "UM", flag: "um", text: "Us Minor Islands" },
  { key: "VI", value: "VI", flag: "vi", text: "Us Virgin Islands" },
  { key: "UZ", value: "UZ", flag: "uz", text: "Uzbekistan" },
  { key: "VU", value: "VU", flag: "vu", text: "Vanuatu" },
  { key: "VA", value: "VA", flag: "va", text: "Vatican City" },
  { key: "VE", value: "VE", flag: "ve", text: "Venezuela" },
  { key: "VN", value: "VN", flag: "vn", text: "Vietnam" },
  { key: "WF", value: "WF", flag: "wf", text: "Wallis and Futuna" },
  { key: "EH", value: "EH", flag: "eh", text: "Western Sahara" },
  { key: "YE", value: "YE", flag: "ye", text: "Yemen" },
  { key: "ZM", value: "ZM", flag: "zm", text: "Zambia" },
  { key: "ZW", value: "ZW", flag: "zw", text: "Zimbabwe" }
];

// src/proton/kyc.ts
async function fetchKycCountries({ chain }) {
  const url = `${this.constants.BLOKS_API}/${chain}/kyc?type=countries&chain=${chain}`;
  const { content: countries } = await this.get(url);
  const countriesById = countries.reduce((acc, country) => {
    acc[country.id] = country;
    return acc;
  }, {});
  return countryOptions_default.filter((countryOption) => countriesById[countryOption.key]);
}
async function checkUserKycStatus({ chain, actor, expectedTier }) {
  if (!chain || !actor || !expectedTier) {
    throw new Error("Invalid parameters");
  }
  return new Promise(async (resolve, reject) => {
    const getStatus = async () => {
      const [userInfo] = await this.rpc.isLightKYCVerified(actor);
      if (userInfo && userInfo.isLightKYCVerified) {
        return resolve("PASSED" /* PASSED */);
      }
      const url = `${this.constants.BLOKS_API}/${chain}/kyc?type=status&chain=${chain}&actor=${actor}`;
      const kyc = await this.get(url);
      if (!kyc || !kyc.length) {
        return reject(new Error("Could not fetch KYC record"));
      }
      const matchedTier = kyc.find(({ tier }) => tier === String(expectedTier));
      if (!matchedTier) {
        return reject(new Error("No kyc data matching tier found"));
      }
      const { status } = matchedTier;
      if (!matchedTier.status) {
        return reject(new Error("KYC Status not found"));
      }
      if (status === "PENDING" /* PENDING */) {
        setTimeout(() => getStatus(), 1e3 * 2);
      } else {
        return resolve(status);
      }
    };
    getStatus();
  });
}
async function applyForKyc(params) {
  const url = `${this.constants.BLOKS_API}/${params.chain}/kyc`;
  const data = await this.post(url, {
    type: "apply",
    ...params
  });
  if (data) {
    return data;
  } else {
    throw new Error("Could not apply for KYC");
  }
}

// src/proton/metal.ts
var import_wrap_constants = require("@proton/wrap-constants");

// src/proton/parsers.ts
var z = __toESM(require("zod"));
var chainInfoParser = z.object({
  chainId: z.string(),
  explorerUrl: z.string(),
  explorerName: z.string(),
  resourceTokenSymbol: z.string(),
  resourceTokenContract: z.string(),
  systemTokenSymbol: z.string(),
  systemTokenContract: z.string(),
  rpcEndpoints: z.array(z.string()),
  actionsRpcEndpoints: z.array(z.string()),
  hyperionEndpoints: z.array(z.string()),
  lightEndpoints: z.array(z.string())
});

// src/proton/metal.ts
async function getChainInfo() {
  const url = this.constants.CHAIN === "proton-test" ? "https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/testnet.json" : "https://raw.githubusercontent.com/ProtonProtocol/chain-info/main/mainnet.json";
  try {
    const data = await this.get(url, {});
    return chainInfoParser.parse(data);
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getTokenPrices() {
  const url = this.constants.METAL_PROTON_ENDPOINT + `/v1/chain/exchange-rates/info`;
  try {
    const data = await this.get(url);
    return import_wrap_constants.exchangeRatesParser.parse(data);
  } catch (e) {
    throw new Error(`Could not fetch exchange rates`);
  }
}
async function getWithdrawalFee({ currency, network }) {
  const url = this.constants.METAL_PROTON_ENDPOINT + `/v1/swaps/calculate-estimated-fee`;
  try {
    const data = await this.post(url, { currency, network });
    return import_wrap_constants.withdrawalFeeQuoteParser.parse(data);
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function currentLocation() {
  const url = this.constants.METAL_PROTON_ENDPOINT + `/v1/kyc/ip-info`;
  return await this.get(url);
}
async function getAvailableFeatures(account) {
  try {
    const url = this.constants.METAL_PROTON_ENDPOINT + `/v2/kyc/by-chain-account/${account}/available-features`;
    const res = await this.get(url);
    return res;
  } catch (e) {
    console.log(e);
    return {
      fiat: "FALSE",
      bridge: "FALSE",
      swap: "FALSE",
      loan: "FALSE"
    };
  }
}
async function createAccount(params) {
  const url = this.constants.METAL_PROTON_ENDPOINT + `/v2/users/create`;
  const data = await this.post(url, params);
  return data;
}
async function loginAccount(params) {
  const url = this.constants.METAL_PROTON_ENDPOINT + `/v2/users/login`;
  const data = await this.post(url, params);
  return data;
}
async function loginAccountV3(params) {
  const url = this.constants.METAL_PROTON_ENDPOINT + `/v3/users/login`;
  const data = await this.post(url, params);
  return data;
}

// src/proton/otc.ts
async function otcQuote(body) {
  const url = this.constants.SWAP_URL + `/v1/quote/${body.baseSymbol}/${body.baseAmount}/${body.quoteSymbol}`;
  return await this.get(url);
}
async function otcOrder(id) {
  const url = this.constants.SWAP_URL + `/v1/order/${id}`;
  return await this.get(url);
}

// src/proton/wrap.ts
async function generateAddress(body) {
  const url = this.constants.WRAP_SERVER_URL + "/address/generate";
  return await this.post(url, body);
}
async function deleteAddress(body) {
  const url = this.constants.WRAP_SERVER_URL + "/address/delete";
  return await this.post(url, body);
}
async function withdrawMetal(body) {
  const url = this.constants.WRAP_SERVER_URL + "/withdraw";
  return await this.post(url, body);
}
async function withdrawalHistoryMetal(account) {
  const url = this.constants.WRAP_SERVER_URL + `/withdrawals/${account}`;
  return await this.get(url);
}

// src/proton/general.ts
var import_utils6 = require("@bloks/utils");
async function getXprTotalStakedAndApr() {
  try {
    const [
      { supply },
      { totalrstaked: totalStakedUnparsed },
      {
        continuous_rate,
        inflation_pay_factor,
        votepay_factor
      }
    ] = await Promise.all([
      this.getTokenSupply(this.constants.EOSIO_TOKEN, this.constants.CORE_SYMBOL),
      this.rpc.get_table_rows({
        code: this.constants.EOSIO,
        scope: this.constants.EOSIO,
        table: "globalsd",
        limit: 1
      }).then((res) => res.rows[0]),
      this.rpc.get_table_rows({
        code: this.constants.EOSIO,
        scope: this.constants.EOSIO,
        table: "global4",
        limit: 1
      }).then((res) => res.rows[0])
    ]);
    const additionalInflation = +continuous_rate * supply;
    const new_tokens = additionalInflation;
    const to_yieldfarms = new_tokens / 4;
    const bpandsavings = new_tokens - to_yieldfarms;
    const to_producers = bpandsavings * (1e4 / inflation_pay_factor);
    const to_producers_block = to_producers * (1e4 / votepay_factor);
    const to_producers_vote = to_producers - to_producers_block;
    const savings = bpandsavings - to_producers;
    const to_savings = 2 * savings / 3;
    const to_consortium = savings - to_savings;
    const totalStaked = +totalStakedUnparsed / Math.pow(10, this.constants.CORE_PRECISION);
    const apr = to_savings / totalStaked * 100;
    return {
      supply,
      yieldFarming: to_yieldfarms,
      producers: to_producers,
      producersBlock: to_producers_block,
      producersVote: to_producers_vote,
      consortium: to_consortium,
      staking: to_savings,
      totalStaked,
      apr
    };
  } catch (e) {
    console.log(e);
    return 0;
  }
}
async function getXprVoter(account) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: this.constants.EOSIO,
      scope: this.constants.EOSIO,
      lower_bound: (0, import_utils6.encodeName)(account, false),
      table: "votersxpr",
      limit: 1
    });
    if (rows && rows.length && rows[0].owner === account) {
      return rows[0];
    } else {
      return void 0;
    }
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getXprAccountStakes(account) {
  let stakes = [];
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: this.constants.EOSIO,
      scope: (0, import_utils6.encodeName)(account, false),
      table: "delxpr",
      limit: -1
    });
    if (rows && rows.length) {
      stakes = rows;
    }
  } catch (e) {
    console.log(e);
  }
  return stakes;
}
async function getXprAccountRefund(account) {
  let refund;
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: this.constants.EOSIO,
      scope: (0, import_utils6.encodeName)(account, false),
      table: "refundsxpr",
      limit: -1
    });
    if (rows && rows.length) {
      refund = rows[0];
      refund.quantity = +refund.quantity.split(" ")[0];
    }
  } catch (e) {
    console.log(e);
  }
  return refund;
}
async function getXprOracleData(oracleIndex) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: "oracles",
      scope: "oracles",
      table: "data",
      limit: 1,
      lower_bound: oracleIndex,
      upper_bound: oracleIndex
    });
    if (rows && rows.length) {
      return rows[0];
    } else {
      return void 0;
    }
  } catch (e) {
    console.log(e);
    return void 0;
  }
}
async function getAllOracleFeeds(lower_bound = void 0) {
  try {
    const { rows, more, next_key } = await this.rpc.get_table_rows({
      code: "oracles",
      scope: "oracles",
      table: "feeds",
      limit: -1,
      lower_bound
    });
    if (more) {
      const restOfRows = await this.getAllOracleFeeds(next_key);
      return rows.concat(restOfRows);
    } else {
      return rows;
    }
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getSpecificOracleData(feed_index) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: "oracles",
      scope: "oracles",
      table: "data",
      limit: -1,
      lower_bound: feed_index,
      upper_bound: feed_index
    });
    if (rows && rows.length && rows[0].feed_index === feed_index) {
      return rows[0];
    }
  } catch (e) {
    console.log(e);
  }
  return void 0;
}
async function getAllOracleData(lower_bound) {
  try {
    let { rows, more, next_key } = await this.rpc.get_table_rows({
      code: "oracles",
      scope: "oracles",
      table: "data",
      limit: -1,
      lower_bound
    });
    if (more) {
      rows = rows.concat(await this.getAllOracleData(next_key));
    }
    return rows;
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getProtonAvatars(account, limit = 10) {
  if (this.constants.CHAIN.indexOf("proton") !== -1) {
    try {
      const result = await this.rpc.get_table_rows({
        json: true,
        code: "eosio.proton",
        scope: "eosio.proton",
        table: "usersinfo",
        table_key: "",
        key_type: "i64",
        lower_bound: (0, import_utils6.encodeName)(account, false),
        index_position: 1,
        limit
      });
      return result.rows;
    } catch (e) {
      console.log("getProtonAvatar error", e);
    }
  }
  return [];
}
async function getProtonAvatar(account) {
  if (this.constants.CHAIN.indexOf("proton") !== -1) {
    try {
      const result = await this.rpc.get_table_rows({
        json: true,
        code: "eosio.proton",
        scope: "eosio.proton",
        table: "usersinfo",
        table_key: "",
        key_type: "i64",
        lower_bound: (0, import_utils6.encodeName)(account, false),
        index_position: 1,
        limit: 1
      });
      return result.rows.length > 0 && result.rows[0].acc === account ? result.rows[0] : void 0;
    } catch (e) {
      console.log("getProtonAvatar error", e);
    }
  }
  return void 0;
}

// src/resources.ts
var import_utils7 = require("@bloks/utils");
async function getRentbwState() {
  const { rows } = await this.rpc.get_table_rows({
    code: this.constants.EOSIO,
    scope: 0,
    table: "powup.state",
    limit: 1
  });
  return rows[0];
}
async function delegatedBandwidth(account, lower_bound) {
  return this.rpc.get_table_rows({
    json: true,
    code: this.constants.EOSIO,
    scope: (0, import_utils7.encodeName)(account, false),
    table: "delband",
    table_key: "",
    limit: -1,
    lower_bound,
    key_type: "i64",
    index_position: 1
  });
}
async function getAccountDelegatedBandwidth(account) {
  let more = true;
  let rows = [];
  let result = null;
  let lower_bound = "";
  try {
    do {
      result = await this.delegatedBandwidth(account, lower_bound);
      more = result.more;
      rows = rows.concat(result.rows);
      if (more) {
        lower_bound = new BigNumber(
          (0, import_utils7.encodeName)(rows[rows.length - 1].to, false)
        ).plus(1).toString();
      }
    } while (more);
  } catch (e) {
    console.log(e);
  }
  return rows;
}
async function getAccountResources(account) {
  const { rows } = await this.rpc.get_table_rows({
    json: true,
    code: this.constants.EOSIO,
    scope: (0, import_utils7.encodeName)(account, false),
    table: "userres",
    table_key: "",
    limit: 1
  });
  return rows[0];
}
async function getRamPriceInEos() {
  try {
    const ram = await this.rpc.get_table_rows({
      json: true,
      code: this.constants.EOSIO,
      scope: this.constants.EOSIO,
      table: "rammarket",
      table_key: "",
      limit: 10
    });
    const baseString = ram.rows[0].base.balance;
    const base = +baseString.substr(0, baseString.indexOf(" "));
    const quoteString = ram.rows[0].quote.balance;
    const quote = quoteString.substr(0, quoteString.indexOf(" "));
    const price = quote / base;
    let ramPriceEos = Number(price.toFixed(8)) * 1024;
    return ramPriceEos;
  } catch (e) {
    console.log(e);
  }
  return 0;
}

// src/stats.ts
var import_utils8 = require("@bloks/utils");
async function getEosTopStakes(limit = 500) {
  return this.lightApi.get_topstake(limit);
}
async function getEosTopRams(limit = 500) {
  return this.lightApi.get_topram(limit);
}
async function getCurrentNameBids(lower_bound = "", upper_bound = "") {
  let { rows, more, next_key } = await this.rpc.get_table_rows({
    code: this.constants.EOSIO,
    scope: this.constants.EOSIO,
    table: "namebids",
    key_type: "i64",
    lower_bound: lower_bound && lower_bound.length <= 12 ? (0, import_utils8.encodeName)(lower_bound, true) : lower_bound,
    upper_bound: upper_bound && upper_bound.length <= 12 ? (0, import_utils8.encodeName)(upper_bound, true) : upper_bound,
    index_position: 1,
    limit: -1
  });
  if (more) {
    rows = rows.concat(await this.getCurrentNameBids(next_key, upper_bound));
  }
  return rows;
}

// src/rex.ts
var import_utils9 = require("@bloks/utils");
var import_numbers = require("@bloks/numbers");
var chainToRexMap = {
  jungle: "jungle",
  bos: "bos",
  eos: "mainnet",
  telos: "telos"
};
async function getRexQueued(account) {
  try {
    const { rows } = await this.rpc.get_table_rows({
      code: this.constants.EOSIO,
      scope: this.constants.EOSIO,
      table: "rexqueue",
      limit: 1,
      lower_bound: (0, import_utils9.encodeName)(account, false)
    });
    if (rows && rows.length && rows[0].owner === account) {
      return rows[0];
    }
  } catch (e) {
    console.log(e);
  }
  return void 0;
}
async function getRexPool() {
  const { rows } = await this.rpc.get_table_rows({
    code: this.constants.EOSIO,
    scope: this.constants.EOSIO,
    table: "rexpool"
  });
  const pool = rows[0];
  const assetToNumber = (asset) => Number(asset.split(" ")[0]);
  const total_lent = assetToNumber(pool.total_lent);
  const total_lendable = assetToNumber(pool.total_lendable);
  const total_unlent = assetToNumber(pool.total_unlent);
  const total_rex = assetToNumber(pool.total_rex);
  const total_rent = assetToNumber(pool.total_rent);
  const lent_percent = (0, import_numbers.multiply)((0, import_numbers.divide)(total_lent, total_lendable), 100);
  const rex_price = +(0, import_numbers.divide)(total_lendable, total_rex);
  const resource_price = +(0, import_numbers.divide)(total_unlent, total_rent + 1);
  return {
    version: pool.version,
    namebid_proceeds: assetToNumber(pool.namebid_proceeds),
    loan_num: pool.loan_num,
    total_lent,
    total_unlent,
    total_rent,
    total_lendable,
    total_rex,
    lent_percent,
    rex_price,
    resource_price
  };
}
async function getRexBalance(account) {
  const { rows } = await this.rpc.get_table_rows({
    code: this.constants.EOSIO,
    scope: this.constants.EOSIO,
    table: "rexbal",
    lower_bound: (0, import_utils9.encodeName)(account, false)
  });
  const bal = rows[0];
  return bal.owner === account ? bal : void 0;
}
async function getRexCpuLoans(account) {
  const { rows } = await this.rpc.get_table_rows({
    json: true,
    code: this.constants.EOSIO,
    scope: this.constants.EOSIO,
    table: "cpuloan",
    table_key: "byowner",
    key_type: "i64",
    limit: 100,
    lower_bound: (0, import_utils9.encodeName)(account, false),
    index_position: 3
  });
  return rows.filter((row) => row.from === account);
}
async function getRexNetLoans(account) {
  const { rows } = await this.rpc.get_table_rows({
    json: true,
    code: this.constants.EOSIO,
    scope: this.constants.EOSIO,
    table: "netloan",
    table_key: "byowner",
    key_type: "i64",
    limit: 100,
    lower_bound: (0, import_utils9.encodeName)(account, false),
    index_position: 3
  });
  return rows.filter((row) => row.from === account);
}
async function getEosDepositedIntoRex(account) {
  const { rows } = await this.rpc.get_table_rows({
    code: this.constants.EOSIO,
    scope: this.constants.EOSIO,
    table: "rexfund",
    lower_bound: (0, import_utils9.encodeName)(account, false)
  });
  const row = rows[0];
  return row.owner === account ? Number(row.balance.split(" ")[0]) : 0;
}
async function getRexReturnRate(type = "mpr") {
  const chain = chainToRexMap[this.constants.CHAIN];
  if (chain) {
    const { data } = await this.post("https://www.api.bloks.io/graphql/v1alpha1/graphql", {
      query: `query {
        ${chain}_${type} {
          ${type}
        }
      }`,
      variables: null
    });
    if (data) {
      return Math.abs(data[`${chain}_${type}`][0][type]);
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}
async function getRexPriceChart() {
  const chain = chainToRexMap[this.constants.CHAIN];
  if (chain) {
    const current_time = (0, import_numbers.formatDate)((0, import_numbers.utcTime)());
    const seven_days_ago = (0, import_numbers.formatDate)((0, import_numbers.utcTime)((0, import_numbers.startDate)((0, import_numbers.time)(), 7)));
    const { data } = await this.post("https://www.api.bloks.io/graphql/v1alpha1/graphql", {
      query: `query {
        ${chain}_pricechart(args: {
          from_time: "${seven_days_ago}",
          to_time: "${current_time}"
        }) {
          t
          o
          h
          l
          c
        }
      }`,
      variables: null
    });
    if (data) {
      return data[`${chain}_pricechart`];
    } else {
      return [];
    }
  } else {
    return { actions: [] };
  }
}

// src/token.ts
async function getEosBalance(accountName) {
  const [balance] = await this.rpc.get_currency_balance(this.constants.EOSIO_TOKEN, accountName, this.constants.CORE_SYMBOL);
  return balance;
}
async function getTokenBalance(contract, accountName, symbol) {
  const result = await this.rpc.get_currency_balance(contract, accountName, symbol).catch((err) => console.log(err));
  if (result && result.length) {
    return result[0];
  } else {
    return null;
  }
}
async function getAccountTokens(accountName) {
  let accountBalances;
  if (!accountBalances) {
    accountBalances = await this.lightGetTokens(accountName);
  }
  if (!accountBalances) {
    accountBalances = await this.hyperionGetTokensForAccount(accountName);
  }
  return accountBalances || [];
}
async function lightGetTokens(account) {
  try {
    const { balances } = await this.lightApi.get_balances(account);
    return balances.map((balance) => ({
      currency: balance.currency,
      amount: Number(balance.amount),
      contract: balance.contract,
      decimals: Number(balance.decimals)
    }));
  } catch (e) {
    console.log("lightGetTokens error", e);
    return void 0;
  }
}
async function hyperionGetTokensForAccount(account) {
  try {
    const { tokens } = await this.hyperion.get_tokens(account);
    return tokens.map((token) => ({
      currency: token.symbol,
      amount: Number(token.amount),
      contract: token.contract,
      decimals: Number(token.precision)
    }));
  } catch (e) {
    console.log("hyperionGetTokensForAccount error", e);
    return void 0;
  }
}
async function getTokenSupply(contract, symbol) {
  try {
    const stats = await this.rpc.get_currency_stats(contract, symbol);
    let { supply, max_supply } = stats[symbol];
    return {
      supply: supply ? +supply.split(" ")[0] : 0,
      max_supply: max_supply ? +max_supply.split(" ")[0] : 0
    };
  } catch (e) {
    console.log(e);
    return {
      supply: 0,
      max_supply: 0
    };
  }
}

// src/transaction.ts
var import_js3 = require("@proton/js");
var import_utils10 = require("@bloks/utils");
async function getHistoryTransaction(txId, blockHint = 0) {
  let eosTransactions = new import_js3.JsonRpc(this.constants.TRANSACTIONS_ENDPOINTS);
  let tx = await eosTransactions.history_get_transaction(txId, blockHint);
  if (!tx)
    throw new Error("TX not found");
  return (0, import_utils10.historyTransformTransaction)(tx);
}
async function getDeferredTransaction(txId) {
  let { transactions } = await this.rpc.get_scheduled_transactions(true, txId, 1);
  if (transactions.length > 0 && transactions[0].trx_id.substring(0, 6) === txId.substring(0, 6)) {
    return (0, import_utils10.historyTransformDeferredTransaction)(transactions[0]);
  }
  return {};
}
async function getHyperionTransaction(id) {
  let result;
  if (this.constants.HYPERION_URL) {
    result = await this.hyperion.get_transaction(id);
  } else {
    result = await this.get(
      (0, import_utils10.urlBuilder)(this.constants.API_URL, "hyperion", {
        type: "get_transaction",
        id,
        options: {}
      })
    );
  }
  if (!result || !result.actions || !result.actions.length)
    throw new Error("TX not found");
  return (0, import_utils10.hyperionTransformTransaction)(result);
}
async function generateTransactionSettings(expireSeconds = 3e3, blocksBehind = 12, delaySec = 0) {
  const info = await this.rpc.get_info();
  let refBlock;
  let result = {};
  if (info) {
    refBlock = await this.rpc.get_block(info.head_block_num - blocksBehind);
    result = import_js3.Serialize.transactionHeader(refBlock, expireSeconds);
  }
  return {
    max_net_usage_words: 0,
    max_cpu_usage_ms: 0,
    delay_sec: delaySec,
    context_free_actions: [],
    actions: [],
    transaction_extensions: [],
    ...result
  };
}

// src/keysAndPermissions.ts
var import_js4 = require("@proton/js");
var import_utils11 = require("@bloks/utils");
function getControlledAccounts(accountName) {
  if (this.constants.HISTORY_TYPES.includes("native")) {
    return this.actionsRpc.history_get_controlled_accounts(accountName);
  } else if (this.constants.HISTORY_TYPES.includes("hyperion")) {
    const actionsRpc = new import_js4.JsonRpc([this.constants.HYPERION_URL]);
    return actionsRpc.history_get_controlled_accounts(accountName);
  } else {
    return [];
  }
}
async function getPermissionLinks(account) {
  if (this.constants.LIGHT_API) {
    try {
      const lightAccount = await this.getAccountLightData(account);
      if (lightAccount) {
        return lightAccount.linkauth.map((auth) => ({
          action: auth.type,
          contract: auth.code,
          permission_name: auth.requirement
        }));
      }
    } catch (e) {
      console.log(e);
    }
  }
  if (this.constants.HISTORY_TYPES.includes("dfuse")) {
    try {
      const { linked_permissions } = await this.get(`${this.constants.API_URL}/dfuse?type=state_permission_links&account=${account}`);
      if (linked_permissions) {
        return linked_permissions;
      }
    } catch (e) {
      console.log(e);
    }
  }
  if (this.constants.HISTORY_TYPES.includes("hyperion")) {
    try {
      const { links } = await this.hyperion.get_links(account);
      return links.map((link) => ({
        action: link.action,
        contract: link.code,
        permission_name: link.permission
      }));
    } catch (e) {
      console.log(e);
    }
  }
  console.log("Permission links not available on chain");
  return [];
}
async function dfuseGetKeyAccounts(key) {
  try {
    const { account_names } = await this.get(
      `${this.constants.API_URL}/dfuse?type=state_key_accounts&publicKey=${key}`
    );
    return account_names && account_names.length ? account_names : [];
  } catch (e) {
    console.log(e);
    console.log("No dfuse accounts found associated with key:", key);
    return [];
  }
}
async function nativeGetKeyAccounts(key) {
  try {
    let keyAccounts = [];
    if (["fio", "fio-test"].includes(this.constants.CHAIN)) {
      const fioAccount = (0, import_utils11.fioKeyToActor)(key.replace("EOS", "FIO"), import_js4.Numeric.stringToPublicKey);
      if (keyAccounts.indexOf(fioAccount) === -1) {
        keyAccounts.push(fioAccount);
      }
    } else {
      const { accounts } = await this.rpc.get_accounts_by_authorizers([], [key]);
      keyAccounts = Array.from(new Set(accounts.map((account) => account.account_name)));
    }
    return keyAccounts;
  } catch (e) {
    console.log(e);
    throw e;
  }
}
async function hyperionGetKeyAccounts(key) {
  if (!this.hyperion) {
    throw new Error("Hyperion API not supported");
  }
  const legacyPublicKey = import_js4.Key.PublicKey.fromString(key).toLegacyString();
  const { account_names } = await this.hyperion.get_key_accounts(legacyPublicKey);
  if (account_names && account_names.length) {
    return account_names;
  } else {
    throw new Error("No keys found");
  }
}
async function lightGetKeyAccounts(key) {
  if (!this.lightApi) {
    throw new Error("Light API not supported");
  }
  const lightChain = this.constants.CHAIN.toLowerCase().replace("-", "");
  const accountsByChain = await this.lightApi.get_key_accounts(key);
  const { accounts } = accountsByChain[lightChain];
  return Array.from(new Set(Object.keys(accounts)));
}
async function getKeyAccountsByType(key, type) {
  switch (type) {
    case "dfuse":
      return await this.dfuseGetKeyAccounts(key);
    case "native":
      return await this.nativeGetKeyAccounts(key);
    case "hyperion":
      return await this.hyperionGetKeyAccounts(key);
    case "light":
    default:
      return await this.lightGetKeyAccounts(key);
  }
}
async function getKeyAccounts(key) {
  if (key.startsWith("FIO")) {
    key = key.replace("FIO", "EOS");
  }
  for (const historyType of [this.constants.HISTORY_TYPES[0], "light", ...this.constants.HISTORY_TYPES.slice(1)]) {
    try {
      const res = await this.getKeyAccountsByType(key, historyType);
      if (res) {
        return res;
      }
    } catch (e) {
      console.log(e);
      continue;
    }
  }
  return [];
}
async function getKeyAccountsForAllChains(key) {
  if (!this.lightApi) {
    throw new Error("Light API not supported");
  }
  try {
    const keyAccounts = await this.lightApi.get_all_key_accounts(key);
    const combined = keyAccounts.reduce((acc, obj) => ({ ...acc, ...obj }), {});
    return Object.entries(combined).reduce((acc, [chain, { accounts: accountsByName }]) => {
      const accounts = Object.keys(accountsByName);
      if (accounts.length) {
        acc.push({
          chain,
          accounts
        });
      }
      return acc;
    }, []);
  } catch (e) {
    console.log(e);
    return [];
  }
}
async function getRequiredAccounts(accountName, permissionName, allPermissions = [], currentLevel = 1, maxLevel = 2) {
  const accountInfo = await this.getAccount(accountName);
  for (const permission of accountInfo.permissions) {
    if (permission.perm_name === permissionName) {
      let accounts = [];
      if (accountName === "eosio" && ["owner", "active"].includes(permission.perm_name)) {
        const producers = await this.getProducersLocal();
        accounts = producers.map((producer) => ({ actor: producer.owner, permission: "active" }));
      }
      if (!accounts.length) {
        accounts = permission.required_auth.accounts.map((account) => account.permission);
      }
      if (!accounts.length) {
        allPermissions.push({ actor: accountName, permission: permissionName });
      }
      for (const account of accounts) {
        if (currentLevel < maxLevel) {
          await this.getRequiredAccounts(account.actor, account.permission, allPermissions, ++currentLevel, maxLevel);
        } else {
          allPermissions.push({ actor: account.actor, permission: account.permission });
        }
      }
    }
  }
  return allPermissions;
}
async function getUsersFromKeys(keys) {
  let users = [];
  const promises = keys.map(async (key) => {
    const account_names = await this.getKeyAccounts(key);
    const promises2 = account_names.map(async (account) => {
      const accountInfo = await this.getAccount(account);
      for (const permission of accountInfo.permissions) {
        if (permission.required_auth.keys.find((permKey) => permKey.key === key)) {
          users.push({
            actor: account,
            permission: permission.perm_name,
            publicKey: key
          });
        }
      }
    });
    await Promise.all(promises2);
  });
  await Promise.all(promises);
  return users;
}

// src/index.ts
var ApiClass = class {
  constructor(chain) {
    this.rpc = void 0;
    this.actionsRpc = void 0;
    this.api = void 0;
    this.hyperion = void 0;
    this.lightApi = void 0;
    this.isInitialized = false;
    this.constants = void 0;
    this.http = http;
    this.get = get;
    this.post = post;
    this.getAccount = getAccount;
    this.getGravatar = getGravatar;
    this.searchAccount = searchAccount;
    this.getParent = getParent;
    this.getAccountLightData = getAccountLightData;
    this.getActionsFromNative = getActionsFromNative;
    this.getActions = getActions;
    this.getActionsFromDfuse = getActionsFromDfuse;
    this.getActionsFromHyperion = getActionsFromHyperion;
    this.getDappStats = getDappStats;
    this.getDspPackages = getDspPackages;
    this.getDapphodlBalance = getDapphodlBalance;
    this.getDappBalance = getDappBalance;
    this.getDappStakes = getDappStakes;
    this.getDapphodlStakes = getDapphodlStakes;
    this.getDappUnstakes = getDappUnstakes;
    this.getDapphodlUnstakes = getDapphodlUnstakes;
    this.getFIOVoter = getFIOVoter;
    this.getFIOPublicKey = getFIOPublicKey;
    this.getFIOAddressByName = getFIOAddressByName;
    this.getFIODomainByName = getFIODomainByName;
    this.getNFTsByFioAddress = getNFTsByFioAddress;
    this.getDomains = getDomains;
    this.getAddresses = getAddresses;
    this.getFIOProducers = getFIOProducers;
    this.getFIOSupplyBreakdown = getFIOSupplyBreakdown;
    this.getFIOFees = getFIOFees;
    this.addFIOFeeToActions = addFIOFeeToActions;
    this.getFIOAddresses = getFIOAddresses;
    this.getFIODomains = getFIODomains;
    this.getFIOAddressesAndDomains = getFIOAddressesAndDomains;
    this.getFIOBalance = getFIOBalance;
    this.getControlledAccounts = getControlledAccounts;
    this.getPermissionLinks = getPermissionLinks;
    this.dfuseGetKeyAccounts = dfuseGetKeyAccounts;
    this.nativeGetKeyAccounts = nativeGetKeyAccounts;
    this.hyperionGetKeyAccounts = hyperionGetKeyAccounts;
    this.lightGetKeyAccounts = lightGetKeyAccounts;
    this.getKeyAccountsByType = getKeyAccountsByType;
    this.getKeyAccounts = getKeyAccounts;
    this.getKeyAccountsForAllChains = getKeyAccountsForAllChains;
    this.getRequiredAccounts = getRequiredAccounts;
    this.getUsersFromKeys = getUsersFromKeys;
    this.getAllMsigs = getAllMsigs;
    this.parsePackedMsigActions = parsePackedMsigActions;
    this.parsePackedMsig = parsePackedMsig;
    this.getFullMsigProposal = getFullMsigProposal;
    this.getMsigApprovals = getMsigApprovals;
    this.getAccountsMsigProposals = getAccountsMsigProposals;
    this.hyperionGetMsig = hyperionGetMsig;
    this.getMsigProposal = getMsigProposal;
    this.getRentbwState = getRentbwState;
    this.delegatedBandwidth = delegatedBandwidth;
    this.getAccountDelegatedBandwidth = getAccountDelegatedBandwidth;
    this.getAccountResources = getAccountResources;
    this.getRamPriceInEos = getRamPriceInEos;
    this.getRexQueued = getRexQueued;
    this.getRexPool = getRexPool;
    this.getRexBalance = getRexBalance;
    this.getRexCpuLoans = getRexCpuLoans;
    this.getRexNetLoans = getRexNetLoans;
    this.getEosDepositedIntoRex = getEosDepositedIntoRex;
    this.getRexReturnRate = getRexReturnRate;
    this.getRexPriceChart = getRexPriceChart;
    this.getEosTopStakes = getEosTopStakes;
    this.getEosTopRams = getEosTopRams;
    this.getCurrentNameBids = getCurrentNameBids;
    this.getEosBalance = getEosBalance;
    this.getTokenBalance = getTokenBalance;
    this.hyperionGetTokensForAccount = hyperionGetTokensForAccount;
    this.getTokenSupply = getTokenSupply;
    this.lightGetTokens = lightGetTokens;
    this.getAccountTokens = getAccountTokens;
    this.getHistoryTransaction = getHistoryTransaction;
    this.getDeferredTransaction = getDeferredTransaction;
    this.getHyperionTransaction = getHyperionTransaction;
    this.generateTransactionSettings = generateTransactionSettings;
    this.getProxies = getProxies;
    this.getVoters = getVoters;
    this.calculateVoteWeight = calculateVoteWeight;
    this.weightedVoteToNumber = weightedVoteToNumber;
    this.getProxyData = getProxyData;
    this.getVoter = getVoter;
    this.getProducers = getProducers;
    this.getProducersLocal = getProducersLocal;
    this.getChainTable = getChainTable;
    this.fetchKycCountries = fetchKycCountries;
    this.checkUserKycStatus = checkUserKycStatus;
    this.applyForKyc = applyForKyc;
    this.currentLocation = currentLocation;
    this.getAvailableFeatures = getAvailableFeatures;
    this.otcQuote = otcQuote;
    this.otcOrder = otcOrder;
    this.generateAddress = generateAddress;
    this.deleteAddress = deleteAddress;
    this.withdrawMetal = withdrawMetal;
    this.withdrawalHistoryMetal = withdrawalHistoryMetal;
    this.getTokenPrices = getTokenPrices;
    this.getWithdrawalFee = getWithdrawalFee;
    this.getChainInfo = getChainInfo;
    this.createAccount = createAccount;
    this.loginAccount = loginAccount;
    this.loginAccountV3 = loginAccountV3;
    this.getXprTotalStakedAndApr = getXprTotalStakedAndApr;
    this.getXprVoter = getXprVoter;
    this.getXprAccountStakes = getXprAccountStakes;
    this.getXprAccountRefund = getXprAccountRefund;
    this.getXprOracleData = getXprOracleData;
    this.getAllOracleFeeds = getAllOracleFeeds;
    this.getAllOracleData = getAllOracleData;
    this.getSpecificOracleData = getSpecificOracleData;
    this.getProtonAvatar = getProtonAvatar;
    this.getProtonAvatars = getProtonAvatars;
    if (chain) {
      import_constants.constants.initialize(chain);
      this.initialize(import_constants.constants);
    }
  }
  initialize(constants, {
    rpcEndpoints,
    actionsRpcEndpoints,
    lightEndpoint,
    hyperionEndpoint
  } = {}) {
    this.constants = constants;
    this.rpc = new import_js5.JsonRpc(rpcEndpoints || this.constants.DEFAULT_ENDPOINTS);
    this.actionsRpc = new import_js5.JsonRpc(actionsRpcEndpoints || this.constants.ACTIONS_ENDPOINTS);
    this.api = new import_js5.Api({ rpc: this.rpc });
    const lightUrl = lightEndpoint || this.constants.LIGHT_API;
    if (lightUrl) {
      this.lightApi = new LightApi.JsonRpc(this.constants.CHAIN.toLowerCase().replace("-", ""), { endpoint: lightUrl });
    }
    const hyperionUrl = hyperionEndpoint || this.constants.HYPERION_URL;
    if (hyperionUrl) {
      this.hyperion = new Hyperion.JsonRpc(hyperionUrl);
    }
    this.isInitialized = true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApiClass,
  KycStatus
});
