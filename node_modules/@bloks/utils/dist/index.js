"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DbopOp: () => DbopOp,
  Nft: () => Nft,
  bytesToString: () => bytesToString,
  charidx: () => charidx,
  cloneDeepArrayOfObj: () => cloneDeepArrayOfObj,
  copy: () => copy,
  decodeName: () => decodeName,
  dfuseDepthFirstExtract: () => dfuseDepthFirstExtract,
  dfuseTransformDeferredAction: () => dfuseTransformDeferredAction,
  dfuseTransformDeferredTransaction: () => dfuseTransformDeferredTransaction,
  dfuseTransformGetActions: () => dfuseTransformGetActions,
  dfuseTransformTrace: () => dfuseTransformTrace,
  dfuseTransformTransaction: () => dfuseTransformTransaction,
  dfuseTransformTransactionResult: () => dfuseTransformTransactionResult,
  encodeName: () => encodeName,
  fioKeyToActor: () => fioKeyToActor,
  hexToUint8Array: () => hexToUint8Array,
  historyTransformDeferredAction: () => historyTransformDeferredAction,
  historyTransformDeferredTransaction: () => historyTransformDeferredTransaction,
  historyTransformFlatTraces: () => historyTransformFlatTraces,
  historyTransformRecursiveTrace: () => historyTransformRecursiveTrace,
  historyTransformTransaction: () => historyTransformTransaction,
  hyperionTransformFlatTraces: () => hyperionTransformFlatTraces,
  hyperionTransformGetActions: () => hyperionTransformGetActions,
  hyperionTransformTransaction: () => hyperionTransformTransaction,
  isString: () => isString,
  nativeTransformGetActions: () => nativeTransformGetActions,
  parseAaNft: () => parseAaNft,
  parseSaNft: () => parseSaNft,
  sha: () => sha,
  string_to_uint128_hash: () => string_to_uint128_hash,
  urlBuilder: () => urlBuilder,
  wait: () => wait
});
module.exports = __toCommonJS(src_exports);

// src/arrays.ts
function cloneDeepArrayOfObj(array) {
  return [...array].map((i) => ({ ...i }));
}

// src/encoding.ts
var import_long = __toESM(require("long"));
var import_fast_text_encoding = require("fast-text-encoding");
var charmap = ".12345abcdefghijklmnopqrstuvwxyz";
function charidx(ch) {
  const idx = charmap.indexOf(ch);
  if (idx === -1) {
    throw new TypeError(`Invalid character: '${ch}'`);
  }
  return idx;
}
function encodeName(name, littleEndian = false) {
  if (typeof name !== "string") {
    throw new TypeError("name parameter is a required string");
  }
  if (name.length > 12) {
    throw new TypeError("A name can be up to 12 characters long");
  }
  let bitstr = "";
  for (let i = 0; i <= 12; i++) {
    const c = i < name.length ? charidx(name[i]) : 0;
    const bitlen = i < 12 ? 5 : 4;
    let bits = Number(c).toString(2);
    if (bits.length > bitlen) {
      throw new TypeError("Invalid name " + name);
    }
    bits = "0".repeat(bitlen - bits.length) + bits;
    bitstr += bits;
  }
  const value = import_long.default.fromString(bitstr, true, 2);
  let leHex = "";
  const bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();
  for (const b of bytes) {
    const n = Number(b).toString(16);
    leHex += (n.length === 1 ? "0" : "") + n;
  }
  const ulName = import_long.default.fromString(leHex, true, 16).toString();
  return ulName.toString();
}
function decodeName(encodedName, littleEndian = true) {
  const value = import_long.default.fromString(encodedName);
  let beHex = "";
  const bytes = littleEndian ? value.toBytesLE() : value.toBytesBE();
  for (const b of bytes) {
    const n = Number(b).toString(16);
    beHex += (n.length === 1 ? "0" : "") + n;
  }
  beHex += "0".repeat(16 - beHex.length);
  const fiveBits = import_long.default.fromNumber(31, true);
  const fourBits = import_long.default.fromNumber(15, true);
  const beValue = import_long.default.fromString(beHex, true, 16);
  let str = "";
  let tmp = beValue;
  for (let i = 0; i <= 12; i++) {
    const c = charmap[tmp.and(i === 0 ? fourBits : fiveBits)];
    str = c + str;
    tmp = tmp.shiftRight(i === 0 ? 4 : 5);
  }
  str = str.replace(/\.+$/, "");
  return str;
}
var shorten_key = (key) => {
  let res = new import_long.default(0, 0, true);
  let i = 1;
  let len = 0;
  while (len <= 12) {
    if (i >= 33)
      throw new Error("FIO: i too large");
    let trimmed_char = key[i] & (len == 12 ? 15 : 31);
    if (trimmed_char == 0) {
      i++;
      continue;
    }
    let shuffle = len == 12 ? 0 : 5 * (12 - len) - 1;
    res = res.or(import_long.default.fromNumber(shift(trimmed_char, shuffle), true));
    len++;
    i++;
  }
  return res;
};
function shift(number, shift2) {
  return number * Math.pow(2, shift2);
}
var fioKeyToActor = (key, stringToPublicKey) => {
  const pubKey = stringToPublicKey(key, "FIO").data;
  const shortenedPubKey = shorten_key(pubKey);
  const decodedName = decodeName(shortenedPubKey.toString(), false);
  return decodedName.substr(0, 12);
};
function bytesToString(bytes) {
  if (typeof bytes === "string") {
    return bytes;
  }
  return bytes.reduce((acc, byte) => {
    return acc + String.fromCharCode(byte);
  }, "");
}
function isString(string) {
  return Object.prototype.toString.call(string) === "[object String]";
}
async function sha(message, binaryRepresentationOfHex = false, type = "SHA-256") {
  let encodedMessage;
  if (binaryRepresentationOfHex) {
    const matched = message.match(/[\da-f]{2}/gi);
    if (!matched)
      throw Error("Empty message");
    const mapped = matched.map((h) => parseInt(h, 16));
    encodedMessage = new Uint8Array(mapped);
  } else {
    encodedMessage = new TextEncoder().encode(message);
  }
  const hashBuffer = await crypto.subtle.digest(type, encodedMessage);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
async function string_to_uint128_hash(str) {
  const hexBytes = (await sha(str, false, "SHA-1")).match(/../g);
  if (hexBytes) {
    return hexBytes.slice(0, -4).reverse().join("");
  } else {
    return 0;
  }
}

// src/historyApiTransformer.ts
function nativeTransformGetActions(result, constants) {
  result.actions = result.actions.map((action) => {
    if (action["action_trace"]["act"]["account"] === constants.EOSIO && action["action_trace"]["act"]["name"] === "claimrewards" && action["action_trace"]["inline_traces"]) {
      let totalAmount = 0;
      let totalSymbol = "";
      for (const inline_trace of action["action_trace"]["inline_traces"]) {
        if (inline_trace["act"]["data"]["from"] === constants.EOSIO_VPAY || inline_trace["act"]["data"]["from"] === constants.EOSIO_BPAY) {
          let [amount, symbol] = inline_trace["act"]["data"]["quantity"].split(" ");
          totalAmount += Number(amount);
          totalSymbol = symbol;
        }
      }
      action["action_trace"]["act"]["data"]["quantity"] = `${totalAmount.toFixed(
        constants.CORE_PRECISION
      )} ${totalSymbol}`;
    }
    return action;
  }).reverse();
  result.numOfTxLoaded = result.actions.length;
  return result;
}
function hyperionTransformGetActions({
  query_time,
  lib,
  actions,
  total: { relation, value }
}) {
  let transformedActions = [];
  let act_digest = 0;
  for (const action of actions) {
    action.receipt = { act_digest: act_digest++ };
    action.block_time = action["@timestamp"];
    if (action.act.data && action.act.data.amount && action.act.data.symbol) {
      action.act.data.quantity = `${action.act.data.amount} ${action.act.data.symbol}`;
    }
    transformedActions.push({
      action_trace: action
    });
  }
  return {
    lib,
    actions: transformedActions,
    query_time,
    numOfTxLoaded: actions.length,
    total: {
      relation,
      value
    }
  };
}
function dfuseTransformGetActions({ transactions, cursor }, accountName, constants) {
  if (!transactions) {
    return {
      cursor,
      actions: [],
      numOfTxLoaded: 0
    };
  }
  let actions = [];
  for (const transaction of transactions) {
    let { lifecycle, action_idx } = transaction;
    if (!action_idx) {
      lifecycle["execution_trace"]["action_traces"];
      actions = actions.concat(
        lifecycle["execution_trace"]["action_traces"].map((action) => ({ action_trace: action })).reverse()
      );
      continue;
    }
    let current_idx = 0;
    for (const action_trace of lifecycle["execution_trace"]["action_traces"]) {
      if (!action_trace["inline_traces"])
        action_trace["inline_traces"] = [];
      if (action_trace["act"]["account"] === constants.EOSIO && action_trace["act"]["name"] === "claimrewards") {
        let totalAmount = 0;
        let totalSymbol = "";
        for (const inline_trace of action_trace["inline_traces"]) {
          if (inline_trace["act"]["data"]["from"] === constants.EOSIO_VPAY || inline_trace["act"]["data"]["from"] === constants.EOSIO_BPAY) {
            actions.push({ action_trace: inline_trace });
            let [amount, symbol] = inline_trace["act"]["data"]["quantity"].split(" ");
            totalAmount += Number(amount);
            totalSymbol = symbol;
          }
        }
        action_trace["act"]["data"]["quantity"] = `${totalAmount.toFixed(
          constants.CORE_PRECISION
        )} ${totalSymbol}`;
        delete action_trace.inline_traces;
        actions.push({ action_trace });
      } else if (action_trace["act"]["account"] === constants.EOSIO && action_trace["act"]["name"] === "sellrex") {
        for (const inline_trace of action_trace["inline_traces"]) {
          if (inline_trace["act"]["account"] === constants.EOSIO_REX || inline_trace["act"]["name"] === "sellresult") {
            actions.push({ action_trace: inline_trace });
          }
        }
        delete action_trace.inline_traces;
        actions.push({ action_trace });
      } else {
        let local_actions = [];
        current_idx = dfuseExtractActions(
          accountName,
          action_trace,
          local_actions,
          action_idx,
          current_idx
        );
        actions = actions.concat(local_actions.reverse());
      }
      current_idx++;
    }
  }
  return {
    cursor,
    actions,
    numOfTxLoaded: transactions.length
  };
}
function dfuseExtractActions(accountName, action, traces, action_idx, current_idx) {
  if (action_idx.includes(current_idx)) {
    traces.push({
      action_trace: action
    });
  }
  if (action["inline_traces"]) {
    for (const inline_trace of action["inline_traces"]) {
      current_idx++;
      current_idx = dfuseExtractActions(accountName, inline_trace, traces, action_idx, current_idx);
    }
    delete action["inline_traces"];
  }
  return current_idx;
}
function dfuseDepthFirstExtract(result) {
  let { transactions, cursor } = result;
  let actions = [];
  if (transactions) {
    for (const transaction of transactions) {
      let { lifecycle, action_idx } = transaction;
      let traces = lifecycle["execution_trace"]["action_traces"];
      let current_idx = 0;
      for (const trace of traces) {
        current_idx = dfuseDepthFirstExtractHelper(
          trace,
          lifecycle["dbops"],
          actions,
          action_idx,
          current_idx
        );
        current_idx++;
      }
    }
  }
  return {
    actions,
    cursor
  };
}
function dfuseDepthFirstExtractHelper(action, dbops, allActions, action_idx, currentIdx) {
  if (action_idx && action_idx.includes(currentIdx)) {
    allActions.push({
      action_trace: action,
      dbops: dbops.filter((op) => op.action_idx === currentIdx)
    });
  }
  if (action["inline_traces"]) {
    for (const trace of action["inline_traces"]) {
      currentIdx = dfuseDepthFirstExtractHelper(trace, dbops, allActions, action_idx, ++currentIdx);
    }
  }
  return currentIdx;
}
function hyperionTransformFlatTraces(traces) {
  const tracesByOrdinal = traces.reduce((acc, trace) => {
    acc[trace.action_ordinal] = {
      ...trace,
      traces: [],
      account_ram_deltas: trace.account_ram_deltas,
      receivers: trace.notified
    };
    return acc;
  }, {});
  for (const trace of traces.sort((a, b) => b.action_ordinal - a.action_ordinal)) {
    if (trace.creator_action_ordinal === 0 || !tracesByOrdinal[trace.creator_action_ordinal]) {
      continue;
    }
    const currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].traces || [];
    const newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    delete tracesByOrdinal[trace.action_ordinal];
    tracesByOrdinal[trace.creator_action_ordinal].traces = newInlineTraces.concat(currentInlineTraces);
  }
  const result = Object.values(tracesByOrdinal);
  return result;
}
function hyperionTransformTransaction(transaction) {
  const { actions, lib, trx_id } = transaction;
  const firstAction = actions[0];
  const transformedActions = firstAction.parent ? actions.filter((trace) => trace.parent === 0) : actions;
  const traces = hyperionTransformFlatTraces(actions);
  return {
    status: "Executed",
    cpu_usage: firstAction.cpu_usage_us,
    net_usage: firstAction.net_usage_words * 8,
    id: trx_id,
    block_time: firstAction["@timestamp"],
    block_num: firstAction["block_num"],
    delay_sec: "N/A",
    expiration: "N/A",
    lib,
    actions: transformedActions,
    traces
  };
}
function dfuseTransformTrace({
  trace,
  dbops = [],
  ramops = [],
  index = 0
}) {
  const transformed = {
    act: trace.act,
    account_ram_deltas: trace.account_ram_deltas,
    receivers: [trace.receipt.receiver],
    act_digest: trace.receipt.act_digest,
    dbops: (dbops || []).filter((op) => op.action_idx === index),
    ramops: (ramops || []).filter((op) => op.action_idx === index),
    traces: []
  };
  if (trace.inline_traces && trace.inline_traces.length) {
    trace.inline_traces.map((itrace) => {
      index++;
      if (itrace.act.hex_data !== transformed.act.hex_data || itrace.act.name !== transformed.act.name || itrace.act.account !== transformed.act.account) {
        transformed.traces.push(
          dfuseTransformTrace({
            trace: itrace,
            index,
            ramops,
            dbops
          })
        );
      } else {
        if (itrace.inline_traces && itrace.inline_traces.length) {
          for (const iitrace of itrace.inline_traces) {
            index++;
            transformed.traces.push(
              dfuseTransformTrace({
                trace: iitrace,
                index,
                ramops,
                dbops
              })
            );
          }
        }
        if (!transformed.receivers.includes(itrace.receipt.receiver)) {
          transformed.receivers.push(itrace.receipt.receiver);
        }
        transformed.dbops = transformed.dbops.concat(
          (dbops || []).filter((op) => op.action_idx === index)
        );
        transformed.ramops = transformed.ramops.concat(
          (ramops || []).filter((op) => op.action_idx === index)
        );
      }
    });
  }
  return transformed;
}
function dfuseTransformTransaction(result) {
  const {
    execution_trace,
    transaction,
    ramops,
    dbops,
    created_by
  } = result;
  let count = 0;
  const actions = (execution_trace["action_traces"] || []).map((trace) => {
    const transformedTrace = dfuseTransformTrace({
      trace,
      ramops,
      dbops,
      index: count
    });
    const traceCount = inlineTraceCountHelper([trace]);
    count += traceCount;
    return transformedTrace;
  });
  return {
    status: execution_trace.receipt.status,
    cpu_usage: execution_trace.receipt.cpu_usage_us,
    net_usage: execution_trace.receipt.net_usage_words * 8,
    id: execution_trace.id,
    block_time: execution_trace.block_time,
    block_num: execution_trace.block_num,
    delay_sec: transaction.delay_sec,
    expiration: transaction.expiration,
    created_by,
    actions,
    traces: actions
  };
}
function dfuseTransformDeferredAction(action) {
  return {
    act: {
      ...action
    },
    account_ram_deltas: [],
    receivers: [],
    act_digest: "",
    traces: []
  };
}
function dfuseTransformDeferredTransaction(result) {
  const actions = result.transaction.actions.map(dfuseTransformDeferredAction);
  return {
    id: result.id,
    status: "deferred",
    dfuse_status: result.transaction_status,
    sender: result.created_by.sender,
    payer: result.created_by.payer,
    published: result.created_by.published_at,
    delay_until: result.created_by.delay_until,
    expiration: result.transaction.expiration,
    delay_sec: result.transaction.delay_sec,
    actions,
    traces: actions
  };
}
function dfuseTransformTransactionResult(result) {
  return result.execution_trace ? dfuseTransformTransaction(result) : dfuseTransformDeferredTransaction(result);
}
function historyTransformDeferredAction(action) {
  return {
    ...action,
    account_ram_deltas: [],
    receiver: "",
    act_digest: "",
    traces: []
  };
}
function historyTransformDeferredTransaction(transaction) {
  return {
    id: transaction.trx_id,
    status: "deferred",
    sender: transaction.sender,
    payer: transaction.payer,
    published: transaction.published,
    expiration: transaction.expiration,
    delay_until: transaction.delay_until,
    delay_sec: transaction.transaction.delay_sec,
    actions: transaction.transaction.actions,
    traces: transaction.transaction.actions.map(
      (action) => historyTransformDeferredAction(action)
    )
  };
}
function historyTransformRecursiveTrace(action) {
  const transformed = {
    act: action.act,
    account_ram_deltas: action.account_ram_deltas || [],
    receivers: [action.receipt.receiver],
    act_digest: action.receipt.act_digest,
    traces: []
  };
  if (action.inline_traces && action.inline_traces.length) {
    action.inline_traces.forEach((trace) => {
      const sameAsParent = trace.receipt.act_digest === action.receipt.act_digest;
      if (sameAsParent && (trace.inline_traces && trace.inline_traces.length)) {
        transformed.traces = transformed.traces.concat(trace.inline_traces.map(historyTransformRecursiveTrace));
        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        }
      } else if (!sameAsParent) {
        transformed.traces.push(historyTransformRecursiveTrace(trace));
      } else {
        if (!transformed.receivers.includes(trace.receipt.receiver)) {
          transformed.receivers.push(trace.receipt.receiver);
        }
      }
    });
  }
  return transformed;
}
function historyTransformFlatTraces(traces) {
  const tracesByOrdinal = traces.reduce((acc, trace) => {
    acc[trace.action_ordinal] = trace;
    return acc;
  }, {});
  for (const trace of traces.sort((a, b) => b.action_ordinal - a.action_ordinal)) {
    if (trace.creator_action_ordinal === 0) {
      continue;
    }
    const currentInlineTraces = tracesByOrdinal[trace.creator_action_ordinal].inline_traces || [];
    const newInlineTraces = [tracesByOrdinal[trace.action_ordinal]];
    tracesByOrdinal[trace.creator_action_ordinal].inline_traces = newInlineTraces.concat(currentInlineTraces);
  }
  const result = Object.values(tracesByOrdinal).filter((trace) => trace.creator_action_ordinal === 0).map((trace) => ({
    ...trace,
    receivers: [trace.receipt.receiver],
    act_digest: trace.receipt.act_digest
  }));
  return result;
}
function findIfSameTx(inline_traces, act) {
  let match = false;
  for (const trace of inline_traces) {
    if (trace.act.hex_data === act.hex_data && trace.act.name === act.name && trace.act.account === act.account || findIfSameTx(trace.inline_traces, act)) {
      return true;
    }
  }
  return match;
}
function inlineTraceCountHelper(traces) {
  return traces.reduce((acc, trace) => {
    return acc + 1 + inlineTraceCountHelper(trace.inline_traces || []);
  }, 0);
}
function historyTransformTransaction(transaction) {
  if (transaction.trx) {
    let actions = [];
    let delay_sec;
    let expiration;
    let traces;
    if (transaction.traces && transaction.traces.length && "creator_action_ordinal" in transaction.traces[0]) {
      traces = historyTransformFlatTraces(transaction.traces).map(historyTransformRecursiveTrace);
      actions = transaction.traces.filter((trace) => trace.creator_action_ordinal === 0);
      console.log(transaction);
    } else {
      for (const [i, action] of transaction.traces.entries()) {
        const tempTraces = transaction.traces.slice();
        tempTraces.splice(i, i + 1);
        const foundSameHex = tempTraces.find(
          (trace) => findIfSameTx(trace.inline_traces.slice(), action.act)
        );
        if (!foundSameHex) {
          actions.push(action);
        }
      }
      traces = actions.map((action) => historyTransformRecursiveTrace(action));
      if (transaction.traces.length > 0 && actions.length === 0) {
        actions = [];
        let counter = 0;
        let i = 0;
        for (const tx2 of transaction.traces) {
          if (i >= counter) {
            actions.push(tx2);
          }
          counter += inlineTraceCountHelper(tx2.inline_traces);
          i++;
        }
        traces = actions.map((action) => historyTransformRecursiveTrace(action));
      }
      if (transaction.traces.length === 0 && actions.length === 0 && transaction.trx.trx && transaction.trx.trx.actions && transaction.trx.trx.actions.length) {
        traces = transaction.trx.trx.actions.map((action) => ({
          act: action,
          account_ram_deltas: [],
          receivers: action.authorization.map((auth) => auth.actor),
          act_digest: "",
          traces: []
        }));
        actions = traces;
      }
    }
    if (transaction.trx.trx) {
      delay_sec = transaction.trx.trx.delay_sec;
      expiration = transaction.trx.trx.expiration;
    } else {
      delay_sec = "N/A";
      expiration = "N/A";
    }
    const extraFields = {
      ...transaction,
      ...transaction.trx.receipt,
      ...transaction.trx.trx || {}
    };
    let tx = {
      ...extraFields,
      status: transaction.trx.receipt.status,
      cpu_usage: transaction.trx.receipt.cpu_usage_us,
      net_usage: transaction.trx.receipt.net_usage_words * 8,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      transaction_extensions: [],
      delay_sec,
      expiration,
      actions,
      traces
    };
    return tx;
  } else if (transaction.action_traces) {
    return dfuseTransformTransaction(transaction);
  } else {
    let traces = transaction.traces.map((trace) => historyTransformRecursiveTrace(trace));
    return {
      status: "executed",
      cpu_usage: 0,
      net_usage: 0,
      id: transaction.id,
      block_time: transaction.block_time,
      block_num: transaction.block_num,
      delay_sec: 0,
      expiration: 0,
      actions: traces,
      traces
    };
  }
}

// src/serialization.ts
function hexToUint8Array(hex) {
  if (typeof hex !== "string") {
    throw new Error("Expected string containing hex digits");
  }
  if (hex.length % 2) {
    throw new Error("Odd number of hex digits");
  }
  const l = hex.length / 2;
  const result = new Uint8Array(l);
  for (let i = 0; i < l; ++i) {
    const x = parseInt(hex.substr(i * 2, 2), 16);
    if (Number.isNaN(x)) {
      throw new Error("Expected hex string");
    }
    result[i] = x;
  }
  return result;
}

// src/url.ts
var import_qs = __toESM(require("qs"));
function urlBuilder(url, id, params) {
  params = params || {};
  if (typeof id !== "undefined" && id !== null) {
    url += `/${encodeURIComponent(id)}`;
  }
  if (Object.keys(params).length !== 0) {
    const queryString = import_qs.default.stringify(params);
    url += `?${queryString}`;
  }
  return url;
}

// src/dom.ts
function copy(text) {
  let selected = false;
  let el = document.createElement("textarea");
  el.value = text;
  el.setAttribute("readonly", "");
  el.style.position = "absolute";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  const selection = document.getSelection();
  if (selection && selection.rangeCount > 0) {
    selected = selection.getRangeAt(0);
  }
  el.select();
  document.execCommand("copy");
  document.body.removeChild(el);
  if (selection && selected) {
    selection.removeAllRanges();
    selection.addRange(selected);
  }
}

// src/models/nft.ts
var Nft = class {
  constructor({
    idata,
    mdata,
    name,
    image,
    video,
    model,
    audio,
    stage,
    skybox,
    pdf,
    id,
    contract,
    link,
    owner,
    author,
    collection,
    mint,
    edition_size
  }) {
    this.idata = idata;
    this.mdata = mdata;
    this.name = name;
    this.image = image;
    this.video = video;
    this.model = model;
    this.audio = audio;
    this.stage = stage;
    this.skybox = skybox;
    this.pdf = pdf;
    this.id = id;
    this.contract = contract;
    this.link = link;
    this.owner = owner;
    this.author = author;
    this.collection = collection;
    this.mint = mint;
    this.edition_size = edition_size;
  }
};

// src/nft.ts
function parseIpfs(imageUrl) {
  if (!imageUrl) {
    return imageUrl;
  }
  if (imageUrl.substring(0, 2) === "Qm") {
    imageUrl = `https://cloudflare-ipfs.com/ipfs/${imageUrl}`;
  }
  return imageUrl;
}
function parseSaNft(nft) {
  let name = nft.idata && nft.idata.name || nft.mdata && nft.mdata.name;
  const imageUrl = parseIpfs(nft.idata && (nft.idata.img || nft.idata.image) || nft.mdata && (nft.mdata.img || nft.mdata.img));
  const videoUrl = parseIpfs(nft.idata && nft.idata.video || nft.mdata && nft.mdata.video);
  const audioUrl = parseIpfs(nft.idata && nft.idata.audio || nft.mdata && nft.mdata.audio);
  const modelUrl = parseIpfs(nft.idata && nft.idata.model || nft.mdata && nft.mdata.model);
  const stageUrl = parseIpfs(nft.idata && nft.idata.stage || nft.mdata && nft.mdata.stage);
  const pdfUrl = parseIpfs(nft.idata && nft.idata.pdf || nft.mdata && nft.mdata.pdf);
  const skyboxUrl = parseIpfs(nft.idata && nft.idata.skybox || nft.mdata && nft.mdata.skybox);
  const nftObj = new Nft({
    idata: nft.idata,
    mdata: nft.mdata,
    name,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.assetId,
    contract: "simpleassets",
    link: `/nft/${nft.assetId}`,
    owner: nft.owner,
    author: nft.author,
    mint: nft.extra && nft.extra.mintNumber,
    collection: nft.category,
    edition_size: nft.extra && nft.extra.totalMinted
  });
  return nftObj;
}
function parseAaNft(nft) {
  const imageUrl = parseIpfs(nft.data.img || nft.data.image);
  const videoUrl = parseIpfs(nft.data.video);
  const audioUrl = parseIpfs(nft.data.audio);
  const modelUrl = parseIpfs(nft.data.model);
  const stageUrl = parseIpfs(nft.data.stage);
  const skyboxUrl = parseIpfs(nft.data.skybox);
  const pdfUrl = parseIpfs(nft.data.pdf);
  let idata = nft.immutable_data;
  if (nft.template && nft.template.immutable_data) {
    idata = { ...idata, ...nft.template.immutable_data };
  }
  const nftObj = new Nft({
    idata,
    mdata: nft.mutable_data,
    name: nft.name || nft.data.name || nft.asset_id,
    image: imageUrl,
    video: videoUrl,
    model: modelUrl,
    audio: audioUrl,
    stage: stageUrl,
    skybox: skyboxUrl,
    pdf: pdfUrl,
    id: nft.asset_id,
    contract: "atomicassets",
    link: `/nft/${nft.asset_id}`,
    owner: nft.owner,
    author: nft.collection.author,
    collection: nft.collection.collection_name,
    mint: nft.template_mint ? +nft.template_mint : void 0,
    edition_size: nft.template ? +nft.template.max_supply || +nft.template.issued_supply : void 0
  });
  return nftObj;
}

// src/random.ts
async function wait(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

// src/types/actions.ts
var DbopOp = /* @__PURE__ */ ((DbopOp2) => {
  DbopOp2["Ins"] = "INS";
  DbopOp2["Rem"] = "REM";
  DbopOp2["Upd"] = "UPD";
  return DbopOp2;
})(DbopOp || {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DbopOp,
  Nft,
  bytesToString,
  charidx,
  cloneDeepArrayOfObj,
  copy,
  decodeName,
  dfuseDepthFirstExtract,
  dfuseTransformDeferredAction,
  dfuseTransformDeferredTransaction,
  dfuseTransformGetActions,
  dfuseTransformTrace,
  dfuseTransformTransaction,
  dfuseTransformTransactionResult,
  encodeName,
  fioKeyToActor,
  hexToUint8Array,
  historyTransformDeferredAction,
  historyTransformDeferredTransaction,
  historyTransformFlatTraces,
  historyTransformRecursiveTrace,
  historyTransformTransaction,
  hyperionTransformFlatTraces,
  hyperionTransformGetActions,
  hyperionTransformTransaction,
  isString,
  nativeTransformGetActions,
  parseAaNft,
  parseSaNft,
  sha,
  string_to_uint128_hash,
  urlBuilder,
  wait
});
