declare function cloneDeepArrayOfObj(array: Array<object>): {}[];

declare function charidx(ch: string): number;
declare function encodeName(name: string, littleEndian?: boolean): string;
declare function decodeName(encodedName: string, littleEndian?: boolean): string;
declare const fioKeyToActor: (key: string, stringToPublicKey: any) => string;
declare function bytesToString(bytes: number[]): string;
/**
 * Checks if string
 */
declare function isString(string: string): boolean;
/**
 *
 * @param message Sha256
 */
declare function sha(message: string, binaryRepresentationOfHex?: boolean, type?: string): Promise<string>;
/**
 * FIO function
 *
 * @param str example: coinomi
 * @returns returns: 968ba84617b73b8e2a73b59170976f41
 */
declare function string_to_uint128_hash(str: string): Promise<string | 0>;

/**
 * Native
 */
interface GetActionsNativeResult {
    actions: Action[];
    last_irreversible_block: number;
    numOfTxLoaded?: number;
}
interface Act {
    account: string;
    name: string;
    authorization: Authorization[];
    data: any;
    hex_data?: string;
}
interface Receipt {
    receiver?: string;
    act_digest?: string | number;
    global_sequence?: number;
    recv_sequence?: number;
    auth_sequence?: Array<Array<number | string>>;
    code_sequence?: number;
    abi_sequence?: number;
}
interface AccountRAMDelta {
    account: string;
    delta: number;
}
/**
 * Hyperion
 */
interface GetActionsHyperionResult {
    query_time: number;
    lib: number;
    total: Total;
    actions: Action[];
    numOfTxLoaded: number;
}
interface Action {
    global_action_seq: number;
    account_action_seq: number;
    block_num: number;
    block_time: Date;
    action_trace: ActionTrace;
}
interface Action {
    act: Act;
    '@timestamp': Date;
    block_num: number;
    producer: string;
    trx_id: string;
    global_sequence: number;
    notified: string[];
    receipt?: Receipt;
}
interface Authorization {
    actor: string;
    permission: string;
}
interface Authorization {
    actor: string;
    permission: string;
}
interface Total {
    value: number;
    relation: string;
}
/**
 * Dfuse
 */
interface GetActionsDfuseResult {
    cursor: string;
    transactions: TransactionElement[];
    numOfTxLoaded: number;
}
interface DfuseAction {
    action_trace: ActionTrace;
    dbops?: Dbop[];
}
interface TransactionElement {
    lifecycle: Lifecycle;
    action_idx: number[];
}
interface Lifecycle {
    transaction_status: string;
    id: string;
    transaction: LifecycleTransaction;
    execution_trace: ExecutionTrace;
    execution_block_header: ExecutionBlockHeader;
    dtrxops: null;
    creation_tree: Array<number[]>;
    dbops: Dbop[];
    ramops: Ramop[] | null;
    tableops: Tableop[] | null;
    pub_keys: string[];
    created_by: null;
    canceled_by: null;
    execution_irreversible: boolean;
    creation_irreversible: boolean;
    cancelation_irreversible: boolean;
}
interface Dbop {
    op: DbopOp;
    action_idx: number;
    account: string;
    table: string;
    scope: string;
    key?: string;
    old: New;
    new: New;
}
interface New {
    payer?: string;
    hex?: string;
}
declare enum DbopOp {
    Ins = "INS",
    Rem = "REM",
    Upd = "UPD"
}
interface ExecutionBlockHeader {
    timestamp: Date;
    producer: string;
    confirmed: number;
    previous: string;
    transaction_mroot: string;
    action_mroot: string;
    schedule_version: number;
    new_producers: null;
    header_extensions: any[];
}
interface ExecutionTrace {
    id: string;
    block_num: number;
    block_time: Date;
    producer_block_id: string;
    receipt: ExecutionTraceReceipt;
    elapsed: number;
    net_usage: number;
    scheduled: boolean;
    action_traces: ActionTrace[];
    failed_dtrx_trace: null;
    except: null;
}
interface ActionTrace {
    action_ordinal: number;
    creator_action_ordinal: number;
    closest_unnotified_ancestor_action_ordinal: number;
    receipt: Receipt;
    receiver: string;
    act: Act;
    context_free: boolean;
    elapsed: number;
    console: string;
    trx_id: string;
    block_num: number;
    block_time: Date;
    producer_block_id: string;
    account_ram_deltas: AccountRAMDelta[];
    except: null;
    error_code: null;
}
interface ActionTrace {
    receipt: Receipt;
    act: Act;
    context_free: boolean;
    elapsed: number;
    console: string;
    trx_id: string;
    block_num: number;
    block_time: Date;
    producer_block_id: string;
    account_ram_deltas: AccountRAMDelta[];
    except: null;
    inline_traces?: ActionTrace[];
}
interface ActionElement {
    account: string;
    name: string;
    authorization: Authorization[];
    data?: ActionData;
    hex_data: string;
}
interface ActionData {
    owner?: string;
    from?: string;
    memo?: string;
    quantity?: string;
    to?: string;
    accounts?: string[];
    message?: string;
}
interface PurpleData {
    memo?: string;
    quantity?: string;
    to?: string;
    from?: string;
    message?: string;
}
interface ExecutionTraceReceipt {
    status: string;
    cpu_usage_us: number;
    net_usage_words: number;
}
interface Ramop {
    op: string;
    action_idx: number;
    payer: string;
    delta: number;
    usage: number;
}
interface Tableop {
    op: DbopOp;
    action_idx: number;
    payer: string;
    path: string;
}
interface LifecycleTransaction {
    expiration: Date;
    ref_block_num: number;
    ref_block_prefix: number;
    max_net_usage_words: number;
    max_cpu_usage_ms: number;
    delay_sec: number;
    context_free_actions: any[];
    actions: ActionElement[];
    transaction_extensions: any[];
    signatures: string[];
    context_free_data: any[];
}

declare function nativeTransformGetActions(result: GetActionsNativeResult, constants: any): GetActionsNativeResult;
declare function hyperionTransformGetActions({ query_time, lib, actions, total: { relation, value } }: GetActionsHyperionResult): {
    lib: number;
    actions: {
        action_trace: Action;
    }[];
    query_time: number;
    numOfTxLoaded: number;
    total: {
        relation: string;
        value: number;
    };
};
declare function dfuseTransformGetActions({ transactions, cursor }: GetActionsDfuseResult, accountName: string, constants: any): {
    cursor: string;
    actions: any[];
    numOfTxLoaded: number;
};
declare function dfuseDepthFirstExtract(result: GetActionsDfuseResult): {
    actions: any;
    cursor: string;
};
declare function hyperionTransformFlatTraces(traces: any): unknown[];
declare function hyperionTransformTransaction(transaction: any): {
    status: string;
    cpu_usage: any;
    net_usage: number;
    id: any;
    block_time: any;
    block_num: any;
    delay_sec: string;
    expiration: string;
    lib: any;
    actions: any;
    traces: unknown[];
};
declare function dfuseTransformTrace({ trace, dbops, ramops, index }: {
    trace: any;
    dbops?: Dbop[];
    ramops?: Ramop[];
    index?: number;
}): any;
declare function dfuseTransformTransaction(result: any): {
    status: any;
    cpu_usage: any;
    net_usage: number;
    id: any;
    block_time: any;
    block_num: any;
    delay_sec: any;
    expiration: any;
    created_by: any;
    actions: any;
    traces: any;
};
declare function dfuseTransformDeferredAction(action: any): {
    act: any;
    account_ram_deltas: never[];
    receivers: never[];
    act_digest: string;
    traces: never[];
};
declare function dfuseTransformDeferredTransaction(result: any): {
    id: any;
    status: string;
    dfuse_status: any;
    sender: any;
    payer: any;
    published: any;
    delay_until: any;
    expiration: any;
    delay_sec: any;
    actions: any;
    traces: any;
};
declare function dfuseTransformTransactionResult(result: any): {
    status: any;
    cpu_usage: any;
    net_usage: number;
    id: any;
    block_time: any;
    block_num: any;
    delay_sec: any;
    expiration: any;
    created_by: any;
    actions: any;
    traces: any;
} | {
    id: any;
    status: string;
    dfuse_status: any;
    sender: any;
    payer: any;
    published: any;
    delay_until: any;
    expiration: any;
    delay_sec: any;
    actions: any;
    traces: any;
};
declare function historyTransformDeferredAction(action: any): any;
declare function historyTransformDeferredTransaction(transaction: any): {
    id: any;
    status: string;
    sender: any;
    payer: any;
    published: any;
    expiration: any;
    delay_until: any;
    delay_sec: any;
    actions: any;
    traces: any;
};
declare function historyTransformRecursiveTrace(action: any): {
    act: any;
    account_ram_deltas: any;
    receivers: any[];
    act_digest: any;
    traces: never[];
};
declare function historyTransformFlatTraces(traces: any): any[];
declare function historyTransformTransaction(transaction: any): any;

declare function hexToUint8Array(hex: string): Uint8Array;

declare function urlBuilder(url: string, id: string, params: any): string;

declare function copy(text: string): void;

interface NftInterface {
    idata: any;
    mdata: any;
    name: string;
    image: string;
    video: string;
    model: string;
    audio: string;
    stage: string;
    skybox: string;
    pdf: string;
    id: string;
    contract: string;
    link: string;
    owner: string;
    author: string;
    collection: string;
    mint?: number;
    edition_size?: number;
}
interface AtomicAsset {
    contract: string;
    asset_id: string;
    owner: string;
    is_transferable: boolean;
    is_burnable: boolean;
    collection: {
        collection_name: string;
        name: string;
        img: string;
        author: string;
        allow_notify: boolean;
        authorized_accounts: string[];
        notify_accounts: string[];
        market_fee: number;
        created_at_block: string;
        created_at_time: string;
    };
    schema: {
        schema_name: string;
        format: {
            name: string;
            type: string;
        }[];
        created_at_block: string;
        created_at_time: string;
    };
    template: {
        template_id: string;
        max_supply: string;
        is_transferable: boolean;
        is_burnable: boolean;
        issued_supply: string;
        immutable_data: any;
    };
    mutable_data: any;
    immutable_data: any;
    template_mint: string;
    schema_mint: string;
    collection_mint: string;
    backed_tokens: any;
    burned_by_account: string | null;
    burned_at_block: string | null;
    burned_at_time: string | null;
    updated_at_block: string;
    updated_at_time: string;
    transferred_at_block: string;
    transferred_at_time: string;
    minted_at_block: string;
    minted_at_time: string;
    data: any;
    name: string;
}
interface AtomicAssetsAccountResponse {
    success: boolean;
    data: AtomicAsset[];
}
interface AtomicAssetsIdResponse {
    success: boolean;
    data: AtomicAsset;
    query_time: number;
}
interface SimpleAsset {
    _id: string;
    assetId: string;
    __v: number;
    dirty: boolean;
    dirtyScope: string;
    author: string;
    category: string;
    container: any[];
    containerf: any[];
    idata: any;
    mdata: any;
    owner: string;
    status: string;
    table: string;
    extra?: {
        mintNumber?: number;
        totalMinted?: number;
    };
}
interface SimpleAssetsAccountResponse {
    results: SimpleAsset[];
    extra: {
        total: number;
    };
}

declare class Nft {
    idata: any;
    mdata: any;
    name: string;
    image: string;
    video: string;
    model: string;
    audio: string;
    stage: string;
    skybox: string;
    pdf: string;
    id: string;
    contract: string;
    link: string;
    owner: string;
    author: string;
    collection: string;
    mint: number | undefined;
    edition_size: number | undefined;
    constructor({ idata, mdata, name, image, video, model, audio, stage, skybox, pdf, id, contract, link, owner, author, collection, mint, edition_size }: NftInterface);
}

declare function parseSaNft(nft: SimpleAsset): Nft;
declare function parseAaNft(nft: AtomicAsset): Nft;

declare function wait(ms: number): Promise<unknown>;

export { AccountRAMDelta, Act, Action, ActionData, ActionElement, ActionTrace, AtomicAsset, AtomicAssetsAccountResponse, AtomicAssetsIdResponse, Authorization, Dbop, DbopOp, DfuseAction, ExecutionBlockHeader, ExecutionTrace, ExecutionTraceReceipt, GetActionsDfuseResult, GetActionsHyperionResult, GetActionsNativeResult, Lifecycle, LifecycleTransaction, New, Nft, NftInterface, PurpleData, Ramop, Receipt, SimpleAsset, SimpleAssetsAccountResponse, Tableop, Total, TransactionElement, bytesToString, charidx, cloneDeepArrayOfObj, copy, decodeName, dfuseDepthFirstExtract, dfuseTransformDeferredAction, dfuseTransformDeferredTransaction, dfuseTransformGetActions, dfuseTransformTrace, dfuseTransformTransaction, dfuseTransformTransactionResult, encodeName, fioKeyToActor, hexToUint8Array, historyTransformDeferredAction, historyTransformDeferredTransaction, historyTransformFlatTraces, historyTransformRecursiveTrace, historyTransformTransaction, hyperionTransformFlatTraces, hyperionTransformGetActions, hyperionTransformTransaction, isString, nativeTransformGetActions, parseAaNft, parseSaNft, sha, string_to_uint128_hash, urlBuilder, wait };
