"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Asset: () => Asset,
  ExtendedAsset: () => ExtendedAsset,
  ExtendedSymbol: () => ExtendedSymbol,
  Maths: () => Maths,
  Symbol: () => Symbol2,
  add: () => add,
  bytesToKB: () => bytesToKB,
  calculatePercentage: () => calculatePercentage,
  currencyToSymbol: () => currencyToSymbol,
  dateToUtcTimePoint: () => dateToUtcTimePoint,
  displayAsset: () => displayAsset,
  displayNumber: () => displayNumber,
  displayNumberAsAmount: () => displayNumberAsAmount,
  displayNumberAsAsset: () => displayNumberAsAsset,
  displayNumberAsCurrency: () => displayNumberAsCurrency,
  displayRawNumberAsAsset: () => displayRawNumberAsAsset,
  divide: () => divide,
  emptyTimePoint: () => emptyTimePoint,
  endDate: () => endDate,
  eosDisplayFormatting: () => eosDisplayFormatting,
  formatDate: () => formatDate,
  formatDateLocal: () => formatDateLocal,
  formatEndDate: () => formatEndDate,
  formatStartDate: () => formatStartDate,
  inFuture: () => inFuture,
  inPast: () => inPast,
  isSameDay: () => isSameDay,
  millisecondsFrom: () => millisecondsFrom,
  multiply: () => multiply,
  numberToAmount: () => numberToAmount,
  numberToAmountFormatted: () => numberToAmountFormatted,
  numberToAsset: () => numberToAsset,
  numberToEos: () => numberToEos,
  numberToEosRoundUp: () => numberToEosRoundUp,
  parseCpu: () => parseCpu,
  parseNetAndRam: () => parseNetAndRam,
  parseRex: () => parseRex,
  parseSeconds: () => parseSeconds,
  parseTimestamp: () => parseTimestamp,
  parseUtcTimestamp: () => parseUtcTimestamp,
  secondsFrom: () => secondsFrom,
  split: () => split,
  startDate: () => startDate,
  substract: () => substract,
  time: () => time,
  timestampFromNow: () => timestampFromNow,
  timestampToDate: () => timestampToDate,
  toBN: () => toBN,
  toNumbro: () => toNumbro,
  unixTime: () => unixTime,
  utcTime: () => utcTime,
  utcTimeToLocal: () => utcTimeToLocal,
  utcTimestampFromNow: () => utcTimestampFromNow,
  utcTimestampToDate: () => utcTimestampToDate
});
module.exports = __toCommonJS(src_exports);

// src/assets.ts
var import_bignumber = require("bignumber.js");

// src/utils.ts
var assert = (isTrue, error) => {
  if (isTrue) {
    return;
  } else {
    throw new Error(error);
  }
};

// src/assets.ts
var Maths;
((Maths2) => {
  let Operations;
  ((Operations2) => {
    Operations2["PLUS"] = "plus";
    Operations2["MULTIPLY"] = "multipliedBy";
    Operations2["DIVIDE"] = "dividedBy";
    Operations2["MINUS"] = "minus";
  })(Operations = Maths2.Operations || (Maths2.Operations = {}));
})(Maths || (Maths = {}));
var Asset = class {
  get integerAmount() {
    const factor = Math.pow(10, this.symbol.precision);
    return this.amount.multipliedBy(factor);
  }
  constructor(asset) {
    this.symbol = new Symbol2({
      code: asset.code,
      precision: asset.precision
    });
    this.amount = new import_bignumber.BigNumber(asset.amount);
  }
  static fromString(asset) {
    const [amount, code] = asset.split(" ");
    const precision = (amount.split(".")[1] || []).length;
    return new Asset({
      code,
      precision,
      amount: new import_bignumber.BigNumber(amount)
    });
  }
  static fromSymbol({ symbol, amount }) {
    if (!(symbol instanceof Symbol2)) {
      throw new Error("Invalid symbol");
    }
    return new Asset({
      code: symbol.code,
      precision: symbol.precision,
      amount
    });
  }
  isEqualTo(asset) {
    return this.isLooselyEqualTo(asset) && this.amount == asset.amount;
  }
  isLooselyEqualTo(asset) {
    return this.symbol.isEqualTo(asset.symbol);
  }
  toString() {
    return `${new import_bignumber.BigNumber(this.amount).toFixed(this.symbol.precision, import_bignumber.BigNumber.ROUND_DOWN)} ${this.symbol.code}`;
  }
  modifyAmount(x, method) {
    let amount = new import_bignumber.BigNumber(0);
    if (typeof x === "number" || import_bignumber.BigNumber.isBigNumber(x)) {
      amount = new import_bignumber.BigNumber(x);
    }
    if (x instanceof Asset) {
      assert(this.isLooselyEqualTo(x), "invalid symbol");
      amount = new import_bignumber.BigNumber(x.amount);
    }
    return Asset.fromSymbol({
      symbol: this.symbol,
      amount: this.amount[method](amount)
    });
  }
  plus(x) {
    return this.modifyAmount(x, "plus" /* PLUS */);
  }
  minus(x) {
    return this.modifyAmount(x, "minus" /* MINUS */);
  }
  multipliedBy(x) {
    return this.modifyAmount(x, "multipliedBy" /* MULTIPLY */);
  }
  dividedBy(x) {
    return this.modifyAmount(x, "dividedBy" /* DIVIDE */);
  }
};
var ExtendedAsset = class {
  constructor(extendedAsset) {
    if (!(extendedAsset.quantity instanceof Asset)) {
      throw new Error("Invalid quantity");
    }
    this.quantity = extendedAsset.quantity;
    this.contract = extendedAsset.contract;
  }
  static fromRaw({ quantity, contract }) {
    return new ExtendedAsset({
      quantity: Asset.fromString(quantity),
      contract
    });
  }
  static fromExtendedSymbol(symbol, amount) {
    if (!(symbol instanceof ExtendedSymbol)) {
      throw new Error("Invalid extended symbol");
    }
    return new ExtendedAsset({
      quantity: Asset.fromSymbol({
        symbol: symbol.sym,
        amount
      }),
      contract: symbol.contract
    });
  }
  isEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isEqualTo(extendedAsset.quantity);
  }
  isLooselyEqualTo(extendedAsset) {
    return this.contract === extendedAsset.contract && this.quantity.isLooselyEqualTo(extendedAsset.quantity);
  }
  toString() {
    return `${this.quantity.toString()}@${this.contract}`;
  }
  toExtendedSymbol() {
    return new ExtendedSymbol(this.quantity.symbol, this.contract);
  }
  modifyAmount(x, method) {
    let amount = new import_bignumber.BigNumber(0);
    if (x instanceof ExtendedAsset) {
      assert(this.isLooselyEqualTo(x), "invalid contract or symbol");
      amount = x.quantity;
    } else {
      amount = x;
    }
    return new ExtendedAsset({
      contract: this.contract,
      quantity: this.quantity.modifyAmount(amount, method)
    });
  }
  plus(x) {
    return this.modifyAmount(x, "plus" /* PLUS */);
  }
  minus(x) {
    return this.modifyAmount(x, "minus" /* MINUS */);
  }
  multipliedBy(x) {
    return this.modifyAmount(x, "multipliedBy" /* MULTIPLY */);
  }
  dividedBy(x) {
    return this.modifyAmount(x, "dividedBy" /* DIVIDE */);
  }
};
var Symbol2 = class {
  constructor(symbol) {
    this.precision = symbol.precision;
    this.code = symbol.code;
  }
  static fromString(symbol) {
    const [precision, code] = symbol.split(",");
    return new Symbol2({
      precision: +precision,
      code
    });
  }
  isEqualTo(symbol) {
    return this.code === symbol.code && this.precision === symbol.precision;
  }
  toString() {
    return `${this.precision},${this.code}`;
  }
};
var ExtendedSymbol = class {
  constructor(sym, contract) {
    this.sym = sym;
    this.contract = contract;
  }
  static fromRaw({
    sym,
    contract
  }) {
    return new ExtendedSymbol(Symbol2.fromString(sym), contract);
  }
  isEqualTo(extendedSymbol) {
    return this.sym.isEqualTo(extendedSymbol.sym) && this.contract === extendedSymbol.contract;
  }
  toString() {
    return `${this.sym.toString()}@${this.contract}`;
  }
};

// src/numbers.ts
var import_numbro = __toESM(require("@jafri/numbro"));

// src/constants.ts
var currencyMap = {
  GBP: { symbol: "\xA3", precision: 2 },
  EUR: { symbol: "\u20AC", precision: 2 },
  JPY: { symbol: "\xA5", precision: 0 },
  CAD: { symbol: "CA$", precision: 2 },
  USD: { symbol: "$", precision: 2 },
  INR: { symbol: "\u20B9", precision: 2 },
  CNY: { symbol: "CN\xA5", precision: 2 },
  HKD: { symbol: "HK$", precision: 2 },
  KRW: { symbol: "\u20A9", precision: 0 },
  AUD: { symbol: "AUD$", precision: 2 },
  SAR: { symbol: "SR", precision: 2 },
  ETH: { symbol: "\u039E", precision: 4 },
  BTC: { symbol: "\u20BF", precision: 8 },
  EOS: { symbol: "EOS", precision: 4 },
  XPR: { symbol: "\u03D7", precision: 4 }
};
var assetFormat = {
  decimalSeparator: ".",
  groupSeparator: ",",
  groupSize: 3
};

// src/numbers.ts
var import_bignumber2 = require("bignumber.js");
function toBN(number) {
  return new import_bignumber2.BigNumber(number);
}
function numberToAmount(number, precision, round = import_bignumber2.BigNumber.ROUND_DOWN) {
  if (number === void 0 || typeof number === "number" && isNaN(number)) {
    number = 0;
  }
  return new import_bignumber2.BigNumber(number).toFixed(precision, round);
}
function numberToAmountFormatted(number, precision, round = import_bignumber2.BigNumber.ROUND_DOWN) {
  if (number === void 0 || isNaN(number)) {
    number = 0;
  }
  return new import_bignumber2.BigNumber(number).toFormat(precision, round, assetFormat);
}
function calculatePercentage(balance, percentage, precision) {
  const final = new import_bignumber2.BigNumber(balance).multipliedBy(percentage);
  return numberToAmount(final, precision, import_bignumber2.BigNumber.ROUND_DOWN);
}
function eosDisplayFormatting(value, symbol, precision) {
  return `${numberToAmountFormatted(value, precision)} ${symbol}`;
}
function numberToEos(number, symbol, precision) {
  return `${numberToAmount(number, precision)} ${symbol}`;
}
function numberToEosRoundUp(number, symbol, precision) {
  return `${numberToAmount(number, precision, import_bignumber2.BigNumber.ROUND_UP)} ${symbol}`;
}
function parseRex(rex) {
  return new import_bignumber2.BigNumber(rex).dividedBy(1e4);
}
function currencyToSymbol(currency) {
  return currencyMap[currency];
}
function split(quantity) {
  const [amount, code] = quantity.split(" ");
  const precision = (amount.split(".")[1] || []).length;
  return {
    amount: +amount,
    symbol: {
      code,
      precision
    }
  };
}
function toNumbro(number) {
  return (0, import_numbro.default)(number);
}
function numberToAsset(number, symbol, precision, trimMantissa = false) {
  if (number === void 0 || isNaN(number)) {
    number = 0;
  }
  const amount = (0, import_numbro.default)(number).format({
    thousandSeparated: false,
    mantissa: precision,
    trimMantissa
  });
  return `${amount} ${symbol}`;
}
function displayNumber(number, trimMantissa = false) {
  if (number === void 0 || isNaN(number)) {
    number = 0;
  }
  return (0, import_numbro.default)(number).format({
    thousandSeparated: true,
    trimMantissa
  });
}
function displayNumberAsCurrency({
  number,
  precision,
  average = false,
  lowPrecision = true,
  trimMantissa = false,
  currency = "USD"
}) {
  if (!currencyMap[currency]) {
    throw new Error("Unsupported currency");
  }
  if (number === void 0 || isNaN(number)) {
    number = 0;
  }
  const { symbol, precision: defaultPrecision } = currencyMap[currency];
  const format = {
    thousandSeparated: true,
    mantissa: precision !== void 0 ? precision : defaultPrecision,
    trimMantissa,
    average
  };
  if (average) {
    format.lowPrecision = lowPrecision;
  }
  const formattedNumber = (0, import_numbro.default)(number).format(format);
  return `${symbol}${formattedNumber}`;
}
function displayAsset(asset) {
  const {
    amount,
    symbol: { code }
  } = split(asset);
  return `${displayNumber(amount)} ${code}`;
}
function displayNumberAsAmount(number, precision, trimMantissa = false) {
  if (number === void 0 || isNaN(number)) {
    number = 0;
  }
  return (0, import_numbro.default)(number).format({ thousandSeparated: true, mantissa: precision, trimMantissa });
}
function displayNumberAsAsset(number, symbol, precision, trimMantissa = false) {
  if (number === void 0 || isNaN(number)) {
    number = 0;
  }
  const amount = (0, import_numbro.default)(number).format({
    thousandSeparated: true,
    mantissa: precision,
    trimMantissa
  });
  return `${amount} ${symbol}`;
}
function displayRawNumberAsAsset(number, symbol, precision, trimMantissa = false) {
  return displayNumberAsAsset(number / Math.pow(10, precision), symbol, precision, trimMantissa);
}

// src/bn.ts
var import_bignumber3 = require("bignumber.js");
import_bignumber3.BigNumber.set({ ROUNDING_MODE: 1 });
function add(...numbers) {
  let start = new import_bignumber3.BigNumber(0);
  if (numbers.length) {
    for (const number of numbers) {
      start = start.plus(number);
    }
  }
  return start;
}
function substract(a, b) {
  return new import_bignumber3.BigNumber(a).minus(b);
}
function multiply(a, b) {
  return new import_bignumber3.BigNumber(a).multipliedBy(b);
}
function divide(a, b) {
  return new import_bignumber3.BigNumber(a).dividedBy(b);
}

// src/resources.ts
var import_numbro2 = __toESM(require("@jafri/numbro"));
function bytesToKB(bytes = 0) {
  return (0, import_numbro2.default)(bytes / 1024).format({ thousandSeparated: false, mantissa: 2 });
}
function parseNetAndRam(bytes) {
  let parsedValue = 0;
  let parsedText = "";
  if (bytes < 1024) {
    parsedValue = bytes;
    parsedText = "Bytes";
  } else if (bytes < 1048576) {
    parsedValue = bytes / 1024;
    parsedText = "KB";
  } else if (bytes < 1073741824) {
    parsedValue = bytes / 1048576;
    parsedText = "MB";
  } else if (bytes < 1099511627776) {
    parsedValue = bytes / 1073741824;
    parsedText = "GB";
  } else if (bytes < 1125899906842624) {
    parsedValue = bytes / 1099511627776;
    parsedText = "TB";
  }
  return `${displayNumberAsAmount(parsedValue, 2, true)} ${parsedText}`;
}
function parseCpu(us) {
  let parsedValue = 0;
  let parsedText = "";
  if (us < 1e3) {
    parsedValue = us;
    parsedText = "\xB5s";
  } else if (us < 1e6) {
    parsedValue = us / 1e3;
    parsedText = "ms";
  } else if (us < 6e7) {
    parsedValue = us / 1e6;
    parsedText = "s";
  } else if (us < 36e8) {
    parsedValue = us / 6e7;
    parsedText = "min";
  } else if (us < 36e11) {
    parsedValue = us / 36e8;
    parsedText = "hours";
  } else {
    parsedValue = us / 864e8;
    parsedText = "days";
  }
  return `${displayNumberAsAmount(parsedValue, 2, true)} ${parsedText}`;
}

// src/time.ts
var import_dayjs = __toESM(require("dayjs"));
var import_relativeTime = __toESM(require("dayjs/plugin/relativeTime"));
var import_utc = __toESM(require("dayjs/plugin/utc"));
var import_timezone = __toESM(require("dayjs/plugin/timezone"));
var import_advancedFormat = __toESM(require("dayjs/plugin/advancedFormat"));
import_dayjs.default.extend(import_relativeTime.default);
import_dayjs.default.extend(import_utc.default);
import_dayjs.default.extend(import_timezone.default);
import_dayjs.default.extend(import_advancedFormat.default);
var COMMON_DATE_FORMAT = "MMM-DD-YYYY, hh:mm:ss A";
function time(date) {
  return (0, import_dayjs.default)(date);
}
function utcTime(date) {
  return (0, import_dayjs.default)(date).utc();
}
function utcTimeToLocal(date) {
  return (0, import_dayjs.default)(date).local();
}
function unixTime(unixTimestamp) {
  return import_dayjs.default.unix(unixTimestamp);
}
function formatDate(date, format = COMMON_DATE_FORMAT) {
  return (0, import_dayjs.default)(date).format(format);
}
function formatDateLocal(date, format = COMMON_DATE_FORMAT) {
  return (0, import_dayjs.default)(date).utc().format(format);
}
function timestampToDate(timestamp) {
  return new Date(timestamp);
}
function utcTimestampToDate(timestamp) {
  timestamp = timestamp.slice(-1) === "Z" ? timestamp : timestamp + "Z";
  return new Date(timestamp);
}
function timestampFromNow(timestamp) {
  return time(timestamp).fromNow();
}
function utcTimestampFromNow(timestamp) {
  timestamp = timestamp.slice(-1) === "Z" ? timestamp : timestamp + "Z";
  return time(timestamp).fromNow();
}
function parseTimestamp(timestamp, format = COMMON_DATE_FORMAT) {
  return formatDate(timestampToDate(timestamp), format);
}
function parseUtcTimestamp(timestamp, format = COMMON_DATE_FORMAT) {
  return formatDate(utcTimestampToDate(timestamp), format);
}
function inFuture(date, utc = false) {
  return utc ? utcTime(date).isAfter(utcTime()) : time(date).isAfter(time());
}
function inPast(date, utc = false) {
  return utc ? utcTime(date).isBefore(utcTime()) : time(date).isBefore(time());
}
function isSameDay(start, end = time()) {
  return (0, import_dayjs.default)(start).isSame((0, import_dayjs.default)(end), "day");
}
function secondsFrom(start, end = time()) {
  return (0, import_dayjs.default)(start).diff((0, import_dayjs.default)(end), "second");
}
function millisecondsFrom(start, end = time()) {
  return (0, import_dayjs.default)(start).diff((0, import_dayjs.default)(end));
}
function startDate(startDate2, days = 3) {
  return (0, import_dayjs.default)(startDate2).clone().subtract(days, "days");
}
function formatStartDate(startTimestamp) {
  return startDate(startTimestamp).format("MMM-DD-YYYY, hh:mm:ss A");
}
function endDate(endDate2, days = 3) {
  return (0, import_dayjs.default)(endDate2).clone().add(days, "days");
}
function formatEndDate(endTimestamp) {
  return endDate(endTimestamp).format("MMM-DD-YYYY, hh:mm:ss A");
}
function dateToUtcTimePoint(date = time()) {
  return (0, import_dayjs.default)(date).utc().format("YYYY-MM-DDTHH:mm:ss.SSS");
}
var emptyTimePoint = "1970-01-01T00:00:00.000";
function parseSeconds(seconds) {
  let days = 0;
  let hours = 0;
  let minutes = 0;
  let parsedDate = "";
  if (seconds > 86400) {
    days += Math.floor(seconds / 86400);
    seconds -= days * 86400;
    parsedDate += `${days.toFixed(0)} ${days === 1 ? "Day" : "Days"} `;
  }
  if (seconds > 3600) {
    hours += Math.floor(seconds / 3600);
    seconds -= hours * 3600;
    parsedDate += `${hours.toFixed(0)} ${hours === 1 ? "Hour" : "Hours"} `;
  }
  if (seconds > 60) {
    minutes += Math.floor(seconds / 60);
    seconds -= minutes * 60;
    parsedDate += `${minutes.toFixed(0)} ${minutes === 1 ? "Minute" : "Minutes"} `;
  }
  if (seconds > 0) {
    parsedDate += `${seconds.toFixed(0)} Seconds `;
  }
  return parsedDate;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Asset,
  ExtendedAsset,
  ExtendedSymbol,
  Maths,
  Symbol,
  add,
  bytesToKB,
  calculatePercentage,
  currencyToSymbol,
  dateToUtcTimePoint,
  displayAsset,
  displayNumber,
  displayNumberAsAmount,
  displayNumberAsAsset,
  displayNumberAsCurrency,
  displayRawNumberAsAsset,
  divide,
  emptyTimePoint,
  endDate,
  eosDisplayFormatting,
  formatDate,
  formatDateLocal,
  formatEndDate,
  formatStartDate,
  inFuture,
  inPast,
  isSameDay,
  millisecondsFrom,
  multiply,
  numberToAmount,
  numberToAmountFormatted,
  numberToAsset,
  numberToEos,
  numberToEosRoundUp,
  parseCpu,
  parseNetAndRam,
  parseRex,
  parseSeconds,
  parseTimestamp,
  parseUtcTimestamp,
  secondsFrom,
  split,
  startDate,
  substract,
  time,
  timestampFromNow,
  timestampToDate,
  toBN,
  toNumbro,
  unixTime,
  utcTime,
  utcTimeToLocal,
  utcTimestampFromNow,
  utcTimestampToDate
});
