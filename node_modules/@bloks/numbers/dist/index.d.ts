import { BigNumber } from 'bignumber.js';
import numbro from '@jafri/numbro';
import dayjs from 'dayjs';

declare namespace Maths {
    enum Operations {
        PLUS = "plus",
        MULTIPLY = "multipliedBy",
        DIVIDE = "dividedBy",
        MINUS = "minus"
    }
}
declare class Asset {
    symbol: Symbol;
    amount: BigNumber.Instance;
    get integerAmount(): BigNumber.Instance;
    constructor(asset: {
        code: string;
        precision: number;
        amount: BigNumber.Instance | number | string;
    });
    static fromString(asset: string): Asset;
    static fromSymbol({ symbol, amount }: {
        symbol: Symbol;
        amount: BigNumber.Instance;
    }): Asset;
    isEqualTo(asset: Asset): boolean;
    isLooselyEqualTo(asset: Asset): boolean;
    toString(): string;
    modifyAmount(x: number | BigNumber.Instance | Asset, method: Maths.Operations): Asset;
    plus(x: number): Asset;
    plus(x: Asset): Asset;
    minus(x: number): Asset;
    minus(x: Asset): Asset;
    multipliedBy(x: number): Asset;
    multipliedBy(x: Asset): Asset;
    dividedBy(x: number): Asset;
    dividedBy(x: Asset): Asset;
}
declare class ExtendedAsset {
    quantity: Asset;
    contract: string;
    constructor(extendedAsset: {
        quantity: Asset;
        contract: string;
    });
    static fromRaw({ quantity, contract }: {
        quantity: string;
        contract: string;
    }): ExtendedAsset;
    static fromExtendedSymbol(symbol: ExtendedSymbol, amount: BigNumber.Instance): ExtendedAsset;
    isEqualTo(extendedAsset: ExtendedAsset): boolean;
    isLooselyEqualTo(extendedAsset: ExtendedAsset): boolean;
    toString(): string;
    toExtendedSymbol(): ExtendedSymbol;
    modifyAmount(x: number | BigNumber.Instance | Asset | ExtendedAsset, method: Maths.Operations): ExtendedAsset;
    plus(x: number): ExtendedAsset;
    plus(x: Asset): ExtendedAsset;
    minus(x: number): ExtendedAsset;
    minus(x: Asset): ExtendedAsset;
    multipliedBy(x: number): ExtendedAsset;
    multipliedBy(x: Asset): ExtendedAsset;
    dividedBy(x: number): ExtendedAsset;
    dividedBy(x: Asset): ExtendedAsset;
}
declare class Symbol {
    precision: number;
    code: string;
    constructor(symbol: {
        code: string;
        precision: number;
    });
    static fromString(symbol: string): Symbol;
    isEqualTo(symbol: Symbol): boolean;
    toString(): string;
}
declare class ExtendedSymbol {
    contract: string;
    sym: Symbol;
    constructor(sym: Symbol, contract: string);
    static fromRaw({ sym, contract }: {
        sym: string;
        contract: string;
    }): ExtendedSymbol;
    isEqualTo(extendedSymbol: ExtendedSymbol): boolean;
    toString(): string;
}

declare function toBN(number: string): BigNumber;
declare function numberToAmount(number: number | BigNumber.Instance, precision: number, round?: any): string;
declare function numberToAmountFormatted(number: number, precision: number, round?: 1): string;
declare function calculatePercentage(balance: number, percentage: number, precision: number): string;
declare function eosDisplayFormatting(value: number, symbol: string, precision: number): string;
declare function numberToEos(number: number, symbol: string, precision: number): string;
declare function numberToEosRoundUp(number: number, symbol: string, precision: number): string;
declare function parseRex(rex: number): BigNumber;
/**
 * Converts USD to { symbol: "USD", precision: 4 }
 * @param {*} currency
 */
declare function currencyToSymbol(currency: string): {
    symbol: string;
    precision: number;
};
/**
 * Converts "1000.0000 EOS" to { amount: 1000, symbol: { code: "EOS", precision: 4 }}
 * @param {*} quantity
 */
declare function split(quantity: string): {
    amount: number;
    symbol: {
        code: string;
        precision: number;
    };
};
declare function toNumbro(number: number): numbro.Numbro;
/**
 * Converts 1000 to "1000.0000 EOS"
 * @param {*} asset
 */
declare function numberToAsset(number: number, symbol: number, precision: number, trimMantissa?: boolean): string;
/**
 * DISPLAY FUNCTIONS
 */
/**
 * Converts 1000 to 1,000
 * @param {*} number
 */
declare function displayNumber(number: number, trimMantissa?: boolean): string;
/**
 * Converts 1000 to $1,000 USD
 * @param {*} number
 */
declare function displayNumberAsCurrency({ number, precision, average, lowPrecision, trimMantissa, currency, }: {
    number: number;
    average?: boolean;
    lowPrecision?: boolean;
    trimMantissa?: boolean;
    precision?: number;
    currency?: string;
}): string;
/**
 * Converts "1000.0000 EOS" to "1,000.0000 EOS"
 * @param {*} asset
 */
declare function displayAsset(asset: string): string;
/**
 * Converts 1000 to 1,000.0000
 * @param {*} number
 */
declare function displayNumberAsAmount(number: number, precision: number, trimMantissa?: boolean): string;
/**
 * Converts 1000 to "1,000.0000 EOS"
 * @param {*} number
 */
declare function displayNumberAsAsset(number: number, symbol: string, precision: number, trimMantissa?: boolean): string;
/**
 * Converts 10000000 to "1,000.0000 EOS"
 * @param {*} number
 */
declare function displayRawNumberAsAsset(number: number, symbol: string, precision: number, trimMantissa?: boolean): string;

declare function add(...numbers: Array<number | BigNumber.Instance>): BigNumber;
declare function substract(a: number | BigNumber.Instance, b: number | BigNumber.Instance): BigNumber;
declare function multiply(a: number | BigNumber.Instance, b: number | BigNumber.Instance): BigNumber;
declare function divide(a: number | BigNumber.Instance, b: number | BigNumber.Instance): BigNumber;

declare function bytesToKB(bytes?: number): string;
declare function parseNetAndRam(bytes: number): string;
declare function parseCpu(us: number): string;

/**
 * Time utilities
 */
declare function time(date?: dayjs.ConfigType): dayjs.Dayjs;
declare function utcTime(date?: dayjs.ConfigType): dayjs.Dayjs;
declare function utcTimeToLocal(date?: dayjs.ConfigType): dayjs.Dayjs;
declare function unixTime(unixTimestamp: number): dayjs.Dayjs;
declare function formatDate(date: dayjs.ConfigType, format?: string): string;
declare function formatDateLocal(date: dayjs.ConfigType, format?: string): string;
declare function timestampToDate(timestamp: string): Date;
declare function utcTimestampToDate(timestamp: string): Date;
declare function timestampFromNow(timestamp: string): string;
declare function utcTimestampFromNow(timestamp: string): string;
declare function parseTimestamp(timestamp: string, format?: string): string;
declare function parseUtcTimestamp(timestamp: string, format?: string): string;
declare function inFuture(date: dayjs.ConfigType, utc?: boolean): boolean;
declare function inPast(date: dayjs.ConfigType, utc?: boolean): boolean;
declare function isSameDay(start: dayjs.ConfigType, end?: dayjs.ConfigType): boolean;
declare function secondsFrom(start: dayjs.ConfigType, end?: dayjs.ConfigType): number;
declare function millisecondsFrom(start: dayjs.ConfigType, end?: dayjs.ConfigType): number;
/**
 * Specific to EOS
 */
declare function startDate(startDate: dayjs.ConfigType, days?: number): dayjs.Dayjs;
declare function formatStartDate(startTimestamp: dayjs.ConfigType): string;
declare function endDate(endDate: dayjs.ConfigType, days?: number): dayjs.Dayjs;
declare function formatEndDate(endTimestamp: dayjs.ConfigType): string;
declare function dateToUtcTimePoint(date?: dayjs.ConfigType): string;
declare const emptyTimePoint = "1970-01-01T00:00:00.000";
declare function parseSeconds(seconds: number): string;

export { Asset, ExtendedAsset, ExtendedSymbol, Maths, Symbol, add, bytesToKB, calculatePercentage, currencyToSymbol, dateToUtcTimePoint, displayAsset, displayNumber, displayNumberAsAmount, displayNumberAsAsset, displayNumberAsCurrency, displayRawNumberAsAsset, divide, emptyTimePoint, endDate, eosDisplayFormatting, formatDate, formatDateLocal, formatEndDate, formatStartDate, inFuture, inPast, isSameDay, millisecondsFrom, multiply, numberToAmount, numberToAmountFormatted, numberToAsset, numberToEos, numberToEosRoundUp, parseCpu, parseNetAndRam, parseRex, parseSeconds, parseTimestamp, parseUtcTimestamp, secondsFrom, split, startDate, substract, time, timestampFromNow, timestampToDate, toBN, toNumbro, unixTime, utcTime, utcTimeToLocal, utcTimestampFromNow, utcTimestampToDate };
